---
title: 剑指offer
date: 2022-03-21 20:00:00 +0800
categories: [刷题]
tags: [leetcode]
pin: true
author: 王家乐

toc: true
comments: true
typora-root-url: ../../jlwang1998.github.io
math: false
mermaid: true
---

# **1. 栈**

## **面试题9：用两个栈实现队列**

**题目：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数appendTail 和deleteHead，分别完成在队列尾部插入结点和在队列头部删除结点的功能。**

```c++
#include<iostream>
#include<stack>
#include<queue>

using namespace std;
template<typename T>  //使函数适用于不同的输入类型
class Myqueue {
public:
	//往s1中push数据
	void appendTail(T value) {
		stack1.push(value);
		cout << value << " ";
	}
	//输出s2数据
	T deleteHead() {
		if (stack2.empty()) {
			while (!stack1.empty()) {
				stack2.push(stack1.top());
				stack1.pop();
			}
		}
		if (stack2.empty()) {
			return -1;
		}
		else {
			T deleteItem = stack2.top();
			stack2.pop();
			return deleteItem;
		}
	}

private:
	stack<T>stack1;
	stack<T>stack2;

};
int main() {
	Myqueue<int>mq;
	cout << "inQueue: " << endl;
	mq.appendTail(1);
	mq.appendTail(2);
	mq.appendTail(3);
	cout << endl;
	cout << "queue: " << endl;
	for (int i = 0; i < 3; i++) {
		cout << mq.deleteHead() << " ";
	}
	cout << endl;
	system("pause");
	return 0;
}
```

```objc
// oj版本
class CQueue {
    stack<int>stack1,stack2;
public:
    CQueue() {
        //初始化
        while(!stack1.empty()){
            stack1.pop();
        }
        while(!stack2.empty()){
            stack2.pop();
        }


    }
    
    void appendTail(int value) {
        stack1.push(value);
    }
                                                                                               
    int deleteHead() {
        if(stack2.empty()){
            while(!stack1.empty()){
                stack2.push(stack1.top());
                stack1.pop();
            }
        }
        if(stack2.empty()){
            return -1;
        }
        else{
            int deleteItem = stack2.top();
            stack2.pop();
            return deleteItem;
        }

    }
};
```

## **面试题9：用两个队列实现栈**

```C++
#include<iostream>
#include<queue>
using namespace std;

template<typename T>

class Mystack {
public:
	void push(T value) {
		//如果两个队列都为空，则插入queue1
		if (queue1.empty() && queue2.empty()) {
			queue1.push(value);
		}
		//如果queue1为空，则插入queue2
		if (queue1.empty()) {
			queue2.push(value);
		}
		//如果queue2为空，则插入queue1
		if (queue2.empty()) {
			queue1.push(value);
		}
	}
	T pop() {
		//如果queue1为空
		if (queue1.empty()) {
			//如果queue2为空，则说明栈为空
			if (queue2.empty()) {
				throw new exception("stack is empty");
			}
			else {
				//如果queue2只有一个元素，直接退出
				if (queue2.size() == 1) {
					T result = queue2.front();
					queue2.pop();
					return result;
				}
				else {
					while (queue2.size() != 1) {
						queue1.push(queue2.front());
						queue2.pop();
					}
					T result = queue2.front();
					queue2.pop();
					return result;
				}
			}
		}
		//如果queue1不为空
		else {
			if (queue1.size() == 1) {
				T result = queue1.front();
				queue1.pop();
				return result;
			}
			else {
				while (queue1.size() != 1) {
					queue2.push(queue1.front());
					queue1.pop();
				}
				T result = queue1.front();
				queue1.pop();
				return result;
			}
		}
	}


private:
	queue<T>queue1;
	queue<T>queue2;
};

int main() {
	Mystack<int>stack;
	stack.push(1);
	stack.push(2);
	stack.push(3);
	cout<< "第1次出栈元素是：" << stack.pop() << endl;
	cout << "第2次出栈元素是：" << stack.pop() << endl;
	stack.push(4);
	cout << "第3次出栈元素是：" << stack.pop() << endl;
	cout << "第4次出栈元素是：" << stack.pop() << endl;


	system("pause");
	return 0;
}
```



## **面试题30：包含min函数的栈**

**定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。**

```C++
//添加一个辅助栈，辅助栈的栈顶元素始终为最小值
class MinStack {
public:
    /** initialize your data structure here. */
    MinStack() {
        _min.push(INT_MAX);

    }
    
    void push(int x) {
        st.push(x);
        if(x<=_min.top()){
            _min.push(x);
        }

    }
    
    void pop() {
        if(st.top()==_min.top()){
           
            _min.pop();
        }
        st.pop();
    }
    
    int top() {
        
        return st.top();
    }
    
    int min() {
        return _min.top();

    }
private:
    stack<int>st;
    stack<int>_min;//辅助栈
};
```

## **▲面试题36：二叉搜索树与双向链表**

**输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。**

**三个要素：**

**（1）排序：从小到大，采用中序遍历的方法；**

**（2）双向链表：设置前驱节点pre，使得pre->right=cur，cur->left=pre；**

**（3）构成循环：设头结点为head，尾节点为tail，则使得head->left=tail，tail->right=head**

```c++
//中序遍历
//先左，再根节点，最后右
void dfs(Node *root):
	if(root==nullptr) return;
	dfs(root->left);//左
	cout<<root->val<<endl;//根节点
	dfs(root->right);//右
```

**算法流程：**

**（1）先对特例处理，若root为空，直接return**

**（2）初始化：head和pre**

**（3）递归法中序遍历：dfs(cur)**

- [ ] **终止条件：cur==nullptr时，终止**
- [ ] **递归左子树dfs(cur.left)**
- [ ] **构建链表：当pre为空时，为head节点，当pre不为空时，令pre->right=cur,cur->left=pre，然后更新，令pre=cur**
- [ ] **递归右子树dfs(cur.right)**

**（4）构建循环链表：中序遍历完成后，当前的pre为最后的叶子节点，也就是数字最大的节点，因此令head->left=pre，pre->right=head**

**（5）返回head**

```c++
class Solution {
public:
    Node* treeToDoublyList(Node* root) {
        if(root==nullptr) return nullptr;//特例处理
        dfs(root);//中序遍历
        head->left=pre;//构建循环链表
        pre->right=head;
        return head;
    }
private:
    Node *pre,*head;
    void dfs(Node *cur){
        if(cur==nullptr)return;
        dfs(cur->left);
        if(pre!=nullptr){
            pre->right=cur;
            cur->left=pre;
        }
        else{
            head=cur;
        }      
        pre=cur;
        dfs(cur->right);
    }
};
```

## **面试题31：栈的压入、弹出序列**

**思路：把输入的第一个序列中的数字一次压入辅助栈，每次入栈后，循环判断 “栈顶元素 == 弹出序列的当前元素” 是否成立，将符合弹出序列顺序的栈顶元素全部弹出。**

```c++
class Solution {
public:
    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
        if(pushed.size()==0) return true;
        stack<int>st;
        int j=0;
        for(int i=0;i<pushed.size();i++)
        {
            st.push(pushed[i]);
            while(!st.empty()&&st.top()==popped[j])
            {
                j++;
                st.pop();
            }
        }
        if(st.empty())return true;
        return false;
    }
};
```

## **面试题33：二叉搜索树的后序遍历**

**思路：**

**方法一：递归分治。**

**后序遍历最后一个数字是根节点的值，数组中前面的数字可以分成两部分：第一部分是左子树节点的值，他们的值都小于根节点，第二部分是右子树节点的值，他们的值都大于根节点。因此，先得到左右子树，再分别判断左右子树是否为二叉搜索树。**

```c++
class Solution {
public:
    bool verifyPostorder(vector<int>& postorder) {
        return verify(postorder,0,postorder.size()-1);
    }
private:
    bool verify(vector<int>&postorder,int left,int right)
    {
        if(left>=right) return true;//说明遍历了一遍
        int i=left,j=0;
        while(postorder[i]<postorder[right]) ++i;//左子树
        j=i;
        while(postorder[i]>postorder[right]) ++i;//右子树
        return i==right&&verify(postorder,left,j-1)&&verify(postorder,j,right-1);

    }
};
```

**.▲方法二：迭代，辅助单调栈。**

**比当前节点大的相邻节点一定是它的右子节点。**

**用栈解决，遍历数组所有元素，如果栈为空，把当前元素压入栈。如果不为空，且当前元素大于栈顶元素，说明当前元素是栈顶元素的右子节点，因此把当前元素压入栈。当前元素小于栈顶元素时，说明当前元素是某个节点的左子节点，要找到这个左子节点的父节点，因此让栈顶元素出栈，直到栈为空或者栈顶元素小于当前值为止，其中最后一个出栈的就是当前元素的父节点。**

```c++
class Solution {
public:
    bool verifyPostorder(vector<int>& postorder) {
        stack<int>st;
        int parent = INT_MAX;//父节点
        //倒叙遍历
        for(int i = postorder.size()-1;i>=0;i--){
            int cur=postorder[i];
            //父节点一定比左节点大
            //如果左节点大于父节点，返回false
            if(cur>parent)
            {
                return false;
            }
            //当cur小于st.top()时，即为当前元素为某个节点的左子节点，需要找它的父节点
            while(!st.empty()&&st.top()>cur)
            {
                parent=st.top();
                st.pop();
            }
            
            st.push(cur);
        }
        return true;
    }
};
```

## **40. 最小的K个数**

**输入整数数组 `arr` ，找出其中最小的 `k` 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。**

**示例：**

```
输入：arr = [3,2,1], k = 2
输出：[1,2] 或者 [2,1]
```

**方法一：大顶堆**

**用一个大根堆实时维护数组的前 k 小值。首先将前 k 个数插入大根堆中，随后从第 k+1 个数开始遍历，如果当前遍历到的数比大根堆的堆顶的数要小，就把堆顶的数弹出，再插入当前遍历到的数。最后将大根堆里的数存入数组返回即可。**

**补充知识：C++中的`堆`用优先队列（priority_queue）实现，优先队列具有队列的所有特性，包括基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的，其默认是一个大顶堆。**

```c++
class Solution {
public:
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        vector<int> vec(k, 0);
        if (k == 0) { // 排除 0 的情况
            return vec;
        }
        priority_queue<int> Q;
        for (int i = 0; i < k; ++i) {
            Q.push(arr[i]);
        }
        for (int i = k; i < (int)arr.size(); ++i) {
            if (Q.top() > arr[i]) {
                Q.pop();
                Q.push(arr[i]);
            }
        }
        for (int i = 0; i < k; ++i) {
            vec[i] = Q.top();
            Q.pop();
        }
        return vec;
    }
};
```

**方法二：快速排序**

**使用快速排序，对数组进行排序，然后选取前K个值返回。**

**补充知识：[快速排序](https://blog.csdn.net/qq_28584889/article/details/88136498)**

**vector.assign()函数：void assign(const_iterator first,const_iterator last)，void assign(size_type n,const T& x = T())，将区间[first,last)的元素赋值到当前的vector容器中，或者赋n个值为x的元素到vector容器中，这个容器会清除掉vector容器中以前的内容。**

```c++
class Solution {
public:
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        quickSort(arr, 0, arr.size() - 1);
        vector<int> res;
        res.assign(arr.begin(), arr.begin() + k);
        return res;
    }
private:
    void quickSort(vector<int>& arr, int l, int r) {
        // 子数组长度为 1 时终止递归
        if (l >= r) return;
        // 哨兵划分操作（以 arr[l] 作为基准数）
        int i = l, j = r;
        while (i < j) {
            while (i < j && arr[j] >= arr[l]) j--;
            while (i < j && arr[i] <= arr[l]) i++;
            swap(arr[i], arr[j]);
        }
        swap(arr[i], arr[l]);
        // 递归左（右）子数组执行哨兵划分
        quickSort(arr, l, i - 1);
        quickSort(arr, i + 1, r);
    }
};
```

**方法三：基于快速排序的数组划分**

**题目只要求返回最小的 k 个数，对这 k 个数的顺序并没有要求。因此，只需要将数组划分为 最小的 k 个数 和 其他数字 两部分即可，而快速排序的哨兵划分可完成此目标。**

**根据快速排序原理，如果某次哨兵划分后 基准数正好是第 k+1 小的数字 ，那么此时基准数左边的所有数字便是题目所求的 最小的 k 个数 。**

**根据此思路，考虑在每次哨兵划分后，判断基准数在数组中的索引是否等于 k ，若 true 则直接返回此时数组的前 k 个数字即可。**

```c++
class Solution {
public:
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        if (k >= arr.size()) return arr;
        return quickSort(arr, k, 0, arr.size() - 1);
    }
private:
    vector<int> quickSort(vector<int>& arr, int k, int l, int r) {
        int i = l, j = r;
        while (i < j) {
            while (i < j && arr[j] >= arr[l]) j--;
            while (i < j && arr[i] <= arr[l]) i++;
            swap(arr[i], arr[j]);
        }
        swap(arr[i], arr[l]);
        if (i > k) return quickSort(arr, k, l, i - 1);
        if (i < k) return quickSort(arr, k, i + 1, r);
        vector<int> res;
        res.assign(arr.begin(), arr.begin() + k);
        return res;
    }
};
```

## **41.1 数据流中的中位数**

**如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。**

**例如，**

**[2,3,4] 的中位数是 3**

**[2,3] 的中位数是 (2 + 3) / 2 = 2.5**

**设计一个支持以下两种操作的数据结构：**

**`void addNum(int num) `- 从数据流中添加一个整数到数据结构中。**
**`double findMedian()` - 返回目前所有元素的中位数。**

**示例：**

```
输入：
["MedianFinder","addNum","addNum","findMedian","addNum","findMedian"]
[[],[1],[2],[],[3],[]]
输出：[null,null,null,1.50000,null,2.00000]
```

**建立一个 小顶堆 AA 和 大顶堆 BB ，各保存列表的一半元素，且规定：**

**A保存较大的一半，长度为$\frac N2$(N为偶数)或$\frac {N+1}2$(N为奇数)；**

**B保存较小的一半，长度为$\frac N2$(N为偶数)或$\frac {N-1}2$(N为奇数)；**

**设元素总数为 N = m + n，其中 m*m* 和 n*n* 分别为 A 和 B中的元素个数。**

**当$m=n$（即 N 为 偶数）：需向 A 添加一个元素。实现方法：将新元素 num 插入至 B ，再将 B 堆顶元素插入至 A ；**
**当 $m \ne n$ （即 N 为 奇数）：需向 B 添加一个元素。实现方法：将新元素 num 插入至 A ，再将 A 堆顶元素插入至 B ；**

```c++
class MedianFinder {
public:    
    priority_queue<int,vector<int>,greater<int> >minHeap;//小顶堆，堆顶为最小值
    priority_queue<int,vector<int>,less<int> >maxHeap;//大顶堆,堆顶为最大值
    MedianFinder() {

    }    
    void addNum(int num) {
        //如果大顶堆个数等于小顶堆个数，则将num送入小顶堆
        if(maxHeap.size()==minHeap.size()){
            maxHeap.push(num);
            int top = maxHeap.top();
            maxHeap.pop();
            minHeap.push(top);
        }
        //如果大顶堆个数不等于小顶堆个数，则将num送入大顶堆
        else{
            minHeap.push(num);
            int top = minHeap.top();
            minHeap.pop();
            maxHeap.push(top);
        }
    }    
    double findMedian() {
        if(maxHeap.size()==minHeap.size()){
            return (maxHeap.top()+minHeap.top())*1.0/2;//转化为double类型
        }
        else{
            return minHeap.top()*1.0;
        }
    }
};
```

## **41.2 字符流中第一个不重复的字符**

**请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 "go" 时，第一个只出现一次的字符是 "g" 。当从该字符流中读出前六个字符 “google" 时，第一个只出现一次的字符是"l"。**

**数据范围：字符串长度满足 $1 \le n \le1000$ ，字符串中出现的字符一定在 ASCII 码内。**

**如果当前字符流没有存在出现一次的字符，返回#字符。**

**示例：**

```
输入："google"
返回值："ggg#ll"
```

**思路：对于字符串查找问题，考虑使用哈希表。又是先来先到，考虑使用队列。**

```c++
class Solution
{
public:
  //Insert one char from stringstream
    queue<char> q;
    unordered_map<char, int> mp;
    void Insert(char ch)
    {
         // 如果是第一次出现， 则添加到队列中
         if (mp.find(ch) == mp.end()) {
             q.push(ch);
         }
         // 不管是不是第一次出现，都进行计数
         ++mp[ch];
    }
  //return the first appearence once char in current stringstream
    char FirstAppearingOnce()
    {
        while (!q.empty()) {
            char ch = q.front();
            // 拿出头部，如果是第一次出现，则返回
            if (mp[ch] == 1) {
                return ch;
            }
            // 不是第一次出现，则弹出，然后继续判断下一个头部
            else {
                q.pop();
            }
        }
        return '#';
    }
};
```



# **2. 队列**

## **面试题50：第一个只出现一次的字符**

**方法一：使用哈希表储存频数**

**利用map，先遍历string，储存字符的频数，然后当第一个频数为1的就为题解。**

```C++
class Solution {
public:
    char firstUniqChar(string s) {
        unordered_map<int,int>frequency;
        for(char ch:s)  #从前往后遍历字符串
        {
            ++frequency[ch];
        }
        for(int i=0;i<s.size();i++)
        {
            if(frequency[s[i]]==1)
            {
                return s[i];
            }
        }
        return ' ';

    }
};
```

**方法二：使用哈希表储存索引**

**对方法一进行修改，使得第二次遍历的对象从字符串变为哈希映射。当我们第一次遍历字符串时，设当前遍历到的字符为 c，如果 c不在哈希映射中，我们就将 c 与它的索引作为一个键值对加入哈希映射中，否则我们将 c 在哈希映射中对应的值修改为 -1**

```c++
class Solution {
public:
    char firstUniqChar(string s) {
        unordered_map<char,int>position;
        int n=s.size();
        for(int i=0;i<n;i++)
        {
            //返回被查找元素的个数，如果有，返回1；否则，返回0。
            //注意，map中不存在相同元素，所以返回值只能是1或0。
            //map的键必须是唯一的
            if(position.count(s[i]))
            {
                position[s[i]]=-1;
            }
            else
            {
                position[s[i]]=i;
            }
        }
        int first=n;
        for(auto[_,pos]:position)
        {
            if(pos!=-1&&pos<first)
            {
                first=pos;
            }
        }
        return first==n ? ' ':s[first];
    }
};
```

**方法三：队列**

**队列先入先出。当遍历字符串时，设当前遍历的字符为c，如果c不在哈希映射中，我们就将c与它的索引作为一个二元数组放入队尾，否则就检查队列中的元素是否都满足只出现一次的要求，即我们不断地根据哈希映射中存储的值（是否为 −1）选择弹出队首的元素，直到队首元素「真的」只出现了一次或者队列为空。**

**queue 和 stack 有一些成员函数相似，但在一些情况下，工作方式有些不同：**

- **front()：返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。**
- **back()：返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。**
- **push(const T& obj)：在 queue 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 push_back() 来完成的。**
- **push(T&& obj)：以移动的方式在 queue 的尾部添加元素。这是通过调用底层容器的具有右值引用参数的成员函数 push_back() 来完成的。**
- **pop()：删除 queue 中的第一个元素。**
- **size()：返回 queue 中元素的个数。**
- **empty()：如果 queue 中没有元素的话，返回 true。**
- **emplace()：用传给 emplace() 的参数调用 T 的构造函数，在 queue 的尾部生成对象。**
- **swap(queue<T> &other_q)：将当前 queue 中的元素和参数 queue 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。**

```c++
class Solution {
public:
    char firstUniqChar(string s) {
        unordered_map<char,int>position;
        queue<pair<char,int>>q;
        int n=s.size();
        //遍历string
        for(int i=0;i<n;i++)
        {
            //如果没有出现过
            if(!position.count(s[i]))
            {
                position[s[i]]=i;
                q.emplace(s[i],i);//放入队列尾部
            }
            else
            {
                position[s[i]]=-1;
                while(!q.empty()&&position[q.front().first]==-1)
                {
                    q.pop();//弹出重复的队首字符
                }
            }
        }
        return q.empty() ? ' ':q.front().first;
    }
};
```

## **▲面试题59-1： 滑动窗口的最大值**

**给定一个数组 `nums` 和滑动窗口的大小 `k`，请找出所有滑动窗口里的最大值。**

**方法一：优先队列**

**优先队列：priority_queue，默认为大的数字在队首，优先pop。因此，将窗口的元素放入优先队列中，堆顶的元素为最大值。然后不断往后移动，并判断堆顶元素的是否在窗口内，也就是堆顶元素的下标，如果不在就pop出去。**

```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int n = nums.size();
        if(n==0)
        {
            return nums;
        }
        priority_queue<pair<int,int>>q;
        for(int i=0;i<k;++i)
        {
            q.emplace(nums[i],i);//把位置和数字保存下来
        }
        vector<int>ans = {q.top().first}; //数组存放每个窗口的最大值
        for(int i=k;i<n;++i)
        {
            q.emplace(nums[i],i);
            while(q.top().second<=i-k)
            {
                q.pop();
            }
            ans.push_back(q.top().first); 
        }
        return ans;
    }
};
```

**方法二：单调队列**

**思路：用一个单调队列存储nums的下标，这些下标按照从小到大的顺序被存储。从队尾传入元素，当后传入的元素大于前面的元素时，说明最大值一定是后面的元素，因此将前面的元素pop。因此，队列中下标对应数组nums中的值是单调递减的。**

**单调队列：队首与普通队列一样，只能删除元素。队尾既可以添加元素又可以删除元素。**

**deque容器：可以在头尾两端分别做元素的插入和删除。**

```c++
push_back(elem);//在容器尾部添加一个数据

push_front(elem);//在容器头部插入一个数据

pop_back();//删除容器最后一个数据

pop_front();//删除容器第一个数据

front();//返回第一个数据。

back();//返回最后一个数据
```

```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int n = nums.size();
        if(n==0||k==0) return vector<int>{};
        deque<int>q;
        for(int i=0;i<k;++i)
        {
            while(!q.empty()&&nums[i]>=nums[q.back()])
            {
                q.pop_back();
            }
            q.push_back(i);
        }
        vector<int>ans = {nums[q.front()]};
        for(int i=k;i<n;++i)
        {
            while(!q.empty()&&nums[i]>=nums[q.back()])
            {
                q.pop_back();
            }
            q.push_back(i);
            while(q.front()<=i-k)
            {
                q.pop_front();
            }
            ans.push_back(nums[q.front()]);
        }
        return ans;
    }
};
```

**方法三：分块+预处理**

**不理解**

```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> prefixMax(n), suffixMax(n);
        for (int i = 0; i < n; ++i) {
            if (i % k == 0) {
                prefixMax[i] = nums[i];
            }
            else {
                prefixMax[i] = max(prefixMax[i - 1], nums[i]);
            }
        }
        for (int i = n - 1; i >= 0; --i) {
            if (i == n - 1 || (i + 1) % k == 0) {
                suffixMax[i] = nums[i];
            }
            else {
                suffixMax[i] = max(suffixMax[i + 1], nums[i]);
            }
        }

        vector<int> ans;
        for (int i = 0; i <= n - k; ++i) {
            ans.push_back(max(suffixMax[i], prefixMax[i + k - 1]));
        }
        return ans;
    }
};
```

## **面试题59-2： 队列的最大值**

**请定义一个队列并实现函数 `max_value` 得到队列里的最大值，要求函数`max_value`、`push_back` 和 `pop_front` 的均摊时间复杂度都是O(1)。若队列为空，`pop_front` 和 `max_value` 需要返回 -1**

**方法一：**

**思路：当一个元素进入队列时，它前面所有比它小的元素就不会再对答案产生影响。从队列尾部插入元素时，从队列尾部依次取出比当前元素小的值，直到遇到比他大的元素。从尾部取出元素，需要使用双端队列`deque`，另外添加一个辅助队列，来确定`pop_front`函数的返回值。**

```c++
class MaxQueue {
public:
    MaxQueue() {

    }
    
    int max_value() {
        //deque的队首为最大值
        if(d.empty()) return -1;
        return d.front();

    }
    
    void push_back(int value) {
        //放入时判断队尾元素与当前value大小
        while(!d.empty()&&d.back()<value)
        {
            d.pop_back();
        }
        d.push_back(value);
        q.push(value);

    }
    
    int pop_front() {
        if(q.empty()) return -1;
        int ans = q.front();
        if(ans==d.front())
        {
            d.pop_front();
        }
        q.pop();
        return ans;

    }
private:
    queue<int>q;
    deque<int>d;
};
```

**方法二：暴力**

```c++
class MaxQueue {
    int q[20000];
    int begin = 0, end = 0;
public:
    MaxQueue() {
    }
    
    int max_value() {
        int ans = -1;
        for (int i = begin; i != end; ++i)
            ans = max(ans, q[i]);
        return ans;
    }
    
    void push_back(int value) {
        q[end++] = value;
    }
    
    int pop_front() {
        if (begin == end)
            return -1;
        return q[begin++];
    }
};
```

# **3. 链表**

## **06. 从尾到头打印链表**

**链表：动态数据结构，要找到某个值必须从头节点开始遍历。创建链表时，先生成一个头节点，再动态生成每一个节点，并指向头节点，再更新当前的节点为头节点。**

**巧妙之处：用递归实现**

```c++
//遍历链表
#include<iostream>
using namespace std;

class node {
public:
	int value;
	node* next;
	node() {
		value = 0;
		next = NULL;
	}
};

int main() {
	node* head, * curr;
	head = new node();
	head->next = NULL;
	head->value = 15;
	for (int i = 0; i < 10; i++) {
		curr = new node();
		curr->value = i;
		curr->next = head;
		head = curr;
	}
	while (head != NULL) {
		cout << head->value << endl;
		head = head->next;
	}
}
```

```C++
//在链表中插入和删除
#include<iostream>
using namespace std;

class node {
public:
	int value;
	node* next;
	node() {
		value = 0;
		next = NULL;
	}
};

int main() {
	node* head = NULL,
		* curr = NULL,
		* insert = NULL,
		* next = NULL,
		* pre = NULL;
	//创建头节点
	head = new node();
	head->value = 15;
	head->next = NULL;
	//生成链表
	for (int i = 0; i < 10; i++) {
		curr = new node();
		curr->value = i;
		curr->next = head;
		head = curr;
	}
	curr = head;//取出头结点
	//找到值为5的节点  
	while (curr->value != 5) {
		curr = curr->next;
	}
	//找到值为5的节点的后继节点  
	next = curr->next;
	insert = new node();
	insert->value = 20;
	curr->next = insert;
	insert->next = next;
	//遍历链表，输出每一个元素  
	curr = head;
	while (curr != NULL) {
		cout << curr->value << endl;
		curr = curr->next;
	}

	//再删除链表中值为20的元素
	curr = head;
	while (curr->value != 20) {
		pre = curr;//保存前驱节点
		curr = curr->next;
	}
	//找到值为20的节点
	next = curr->next;
	pre->next = next;
	delete curr;
	//遍历这个链表输出每个元素
	curr = head;
	while (curr != NULL)
	{
		cout << curr->value << endl;
		curr = curr->next;
	}


	return 0;
}
```

```c++
//题解1
//用栈实现
class Solution {
public:
    vector<int> reversePrint(ListNode* head) {
        stack<int>s;
        vector<int>ans;
        while(head)
        {
            s.push(head->val);
            head = head->next;
        }
        while(!s.empty())
        {
            ans.push_back(s.top());
            s.pop();
        }
        return ans;

    }
};
```

```c++
//题解2：递归实现
//当链表较长时，调用函数层级较深，容易溢出
class Solution {
public:
    vector<int> reversePrint(ListNode* head) {
        if(!head){
            return {};
        }
        vector<int>a=reversePrint(head->next);
        a.push_back(head->val);//在数组最后一个添加元素
        return a;
    }
};
```

## **18. 删除链表的节点**
**给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。**

**示例：**

```
输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
```

**思路：循环暴力解决**

```c++
class Solution {
public:
    ListNode* deleteNode(ListNode* head, int val) {
        if(head->val == val) return head->next;
        ListNode *pre = head, *cur = head->next;
        while(cur != nullptr && cur->val != val) {
            pre = cur;
            cur = cur->next;
        }
        if(cur != nullptr) pre->next = cur->next;
        return head;
    }
};
```


## **面试题22：链表中倒数第k个节点**

**输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。**

**例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。**

**思路：定义两个指针，第一个指针从头指针遍历往前走k-1步，从第k步开始，第二个指针也开始从头指针遍历，当第一个指针到达尾结点时，第二个指针到达倒数第k个节点。**

```c++
class Solution {
public:
    ListNode* getKthFromEnd(ListNode* head, int k) {
        ListNode *first = head;
        ListNode *second = nullptr;
        if(k==0||head==nullptr) return nullptr;
        for(int i=0;i<k-1;i++)
        {
            if(first->next!=nullptr)
            {
                first = first->next;
            }
            else return nullptr;//head个数小于k-1
        }
        second = head;
        while(first->next!=nullptr)
        {
            first = first->next;
            second = second->next;
        }
        return second;

    }
};
```

## **23. 链表中环的入口节点**

**给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。**

**<img src="/assets/blog_res/2022-03-21-%E5%89%91%E6%8C%87offer.assets/image-20220223104838703.png" alt="image-20220223104838703" style="zoom: 67%;" />**

**方法一：双指针法**

**<img src="/assets/blog_res/2022-03-21-%E5%89%91%E6%8C%87offer.assets/284295_1587551967334_9F5E82103ABBE2487DFB7C69C5D05D8F.png" alt="img" style="zoom:67%;" />**

1. **初始化：快指针fast指向头结点， 慢指针slow指向头结点**
2. **让fast一次走两步， slow一次走一步，第一次相遇在C处，停止**
3. **然后让fast指向头结点，slow原地不动，让后fast，slow每次走一步，当再次相遇，就是入口结点。** 

```c++
public ListNode EntryNodeOfLoop(ListNode *pHead) {
        if(pHead == null) return null;
        // 定义快慢指针
        ListNode *slow = pHead;
        ListNode *fast = pHead;
        while(fast != null && fast.next != null){
            // 快指针是满指针的两倍速度
            fast = fast->next->next;
            slow = slow->next;
            // 记录快慢指针第一次相遇的结点
            if(slow == fast) break;
        }
        // 若是快指针指向null，则不存在环
        if(fast == null || fast->next == null) return null;
        // 重新指向链表头部
        fast = pHead;
        // 与第一次相遇的结点相同速度出发，相遇结点为入口结点
        while(fast != slow){
            fast = fast->next;
            slow = slow->next;
        }
        return fast;
    }
```

**方法二：哈希表**

**通过使用set或者map来存储已经遍历过的结点，当第一次出现重复的结点时，即为入口结点。**

```c++
class Solution {
public:
    ListNode* EntryNodeOfLoop(ListNode* pHead) {
        unordered_set<ListNode*>st;
        while(pHead){
            if(st.find(pHead)==st.end()){
                st.insert(pHead);
                pHead = pHead->next;
            }
            else{
                return pHead;
            }
        }
        return nullptr;
    }
};
```

## **面试题24：反转链表**

**定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。**

**示例:**

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

**方法一：迭代**

**思路：创建三个指针，指向当前节点、当前节点的上一个节点、当前节点的下一个节点。**

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *cur = head;//当前节点
        ListNode *pre = nullptr;//上一个节点
        ListNode *ReversedHead = nullptr;//反转后的头节点
        while(cur!=nullptr)
        {
            ListNode *next = cur->next;//下一个节点
            if(next==nullptr)
            {
                ReversedHead = cur;
            }
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        return ReversedHead;
    }
};
```

**方法二：递归**

**思路：考虑使用递归法遍历链表，当越过尾节点后终止递归，在回溯时修改各节点的 next 引用指向。**

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        return recur(head,nullptr);
    }
private:
    ListNode* recur(ListNode* cur,ListNode* pre)
    {
        if(cur==nullptr) return pre;// 终止条件，返回反转后的头节点
        ListNode* res = recur(cur->next,cur); // 递归后继节点
        cur->next=pre;// 修改节点引用指向
        return res;// 返回反转链表的头节点
    }
};
```
## **面试题25：合并两个排序的链表**

**输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。**

**示例1：**

```
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
```

**方法一：递归**

**比较两个链表的头结点，取较小的为新链表的头结点，然后继续判断，递归**

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if(l1==nullptr) return l2;
        else if(l2==nullptr) return l1;
        if(l1->val<=l2->val)
        {
            l1->next = mergeTwoLists(l1->next,l2);
            return l1;
        }
        else{
            l2->next = mergeTwoLists(l1,l2->next);
            return l2;
        }

    }
};
```

**方法二：迭代**

**▲<u>不懂为啥要新建两个节点</u>**

**添加一个伪头结点，当l1或l2为空时，跳出。**

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode *res = new ListNode(0),*cur=res;// 建立两个节点，cur每次迭代会变化，而res一直为头节点0
        while(l1!=nullptr&&l2!=nullptr)
        {
            l1->val<=l2->val ? (cur->next=l1,l1=l1->next) :(cur->next=l2,l2=l2->next);
            cur = cur->next;
        }
        cur->next = l1 ? l1:l2;
        return res->next;

    }
};
```

## **▲面试题35：复杂链表的复制**

**请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。**

**示例：**

**![img](/assets/blog_res/2022-03-21-%E5%89%91%E6%8C%87offer.assets/e1.png)**

```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

**方法一：哈希表(空间复杂度高)**

**构建原链表节点 和 新链表对应节点 的键值对映射关系，再遍历构建新链表各节点的 `next` 和 `random` 引用指向即可。**

```c++
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if(head==nullptr)return nullptr;
        Node* cur = head;
        unordered_map<Node*,Node*>map;
        //复制各节点，并建立 “原节点 -> 新节点” 的 Map 映射
        while(cur!=nullptr)
        {
            map[cur] = new Node(cur->val);
            cur = cur->next;
        }
        cur = head;
        //构建新链表的 next 和 random 指向
        while(cur!=nullptr)
        {
            map[cur]->next = map[cur->next];//[]内是索引，类似int
            map[cur]->random = map[cur->random];
            cur = cur->next;
        }
        return map[head];       
    }
};
```

**方法二：拼接+拆分**

**流程：**

**（1）复制各节点，按照原节点、新节点的顺序拼接新链表；**

**（2）构建新链表各节点的random指向`cur->next->random = cur->random->next`；**

**（3）拆分原/新链表**

```c++
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if(head == nullptr) return nullptr;
        Node* cur = head;
        // 1. 复制各节点，并构建拼接链表
        while(cur != nullptr) {
            Node* tmp = new Node(cur->val);
            tmp->next = cur->next;
            cur->next = tmp;
            cur = tmp->next;
        }
        // 2. 构建各新节点的 random 指向
        cur = head;
        while(cur != nullptr) {
            if(cur->random != nullptr)
                cur->next->random = cur->random->next;
            cur = cur->next->next;
        }
        // 3. 拆分两链表
        cur = head->next;
        Node* pre = head, *res = head->next;
        while(cur->next != nullptr) {
            pre->next = pre->next->next;
            cur->next = cur->next->next;
            pre = pre->next;
            cur = cur->next;
        }
        pre->next = nullptr; // 单独处理原链表尾节点
        return res;      // 返回新链表头节点
    }
};
```

## **面试题52：两个链表的第一个公共节点**

**输入两个链表，找出它们的第一个公共节点。**

**如下面的两个链表：**

**![img](/assets/blog_res/2022-03-21-%E5%89%91%E6%8C%87offer.assets/160_statement.png)**

**在节点 c1 开始相交。**

**示例：**

**![img](/assets/blog_res/2022-03-21-%E5%89%91%E6%8C%87offer.assets/160_example_1.png)**

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```

**方法一：书上方法，时间复杂度O(m+n)，空间复杂度O(1)**

**思路：**

**（1）遍历两个链表，得到两个链表的长度；**

**（2）找到较长的链表，长度差为k，使较长的先走k步；**

**（3）两个链表同时遍历，第一个相同的点就是交点。**

```
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
    	//得到两个链表长度
        int lengthA = getListLength(headA);
        int lengthB = getListLength(headB);
        ListNode* headLong = headA;
        ListNode* headShort = headB;
        int lengthDif = lengthA-lengthB;
        if(lengthA<lengthB)
        {
            headLong = headB;
            headShort = headA;
            lengthDif = lengthB-lengthA;
        }
        //长链表先遍历lengthDif步
        for(int i=0;i<lengthDif;i++)
        {
            headLong = headLong->next;
        }
        //同时遍历，找公共节点
        while(headLong!=nullptr&&headShort!=nullptr&&headLong!=headShort)
        {
            headLong = headLong->next;
            headShort = headShort->next;
        }
        return headLong;       
    }
private:
	//得到链表长度
    int getListLength(ListNode* head)
    {
        int n = 0;
        ListNode* cur = head;
        while(cur!=nullptr)
        {
            n++;
            cur = cur->next;
        }
        return n;
    }
};
```

**方法二：哈希集合，时间复杂度O(m+n)，空间复杂度O(m)**

**思路：用哈希集合储存headA，然后遍历headB，判断headB是否有节点在哈希集合内。**

```c++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        unordered_set<ListNode*>visited;
        ListNode* cur = headA;
        while(cur!=nullptr)
        {
            visited.insert(cur);
            cur = cur->next;
        }
        cur = headB;
        while(cur!=nullptr)
        {
            if(visited.count(cur))
            {
                return cur;
            }
            cur = cur->next;
        }
        return nullptr;        
    }
};
```

**方法三：双指针，时间复杂度O(m+n)，空间复杂度O(1)**

**思路：考虑构建两个节点指针 A , B 分别指向两链表头节点 `headA` , `headB` ，做如下操作：**

**（1）指针 A 先遍历完链表 `headA` ，再开始遍历链表 `headB` ，当走到 `node` 时，共走步数为：**
$$
a+(b-c)
$$
**（2）指针B先遍历完链表`headB` ，再开始遍历链表 `headA` ，当走到 `node` 时，共走步数为：**
$$
b+(a-c)
$$
**如下式所示，此时指针A，B重合，并有两种情况：**
$$
a+(b-c)=b+(a-c)
$$

1. **若两链表有公共尾部 (即 c > 0 ) ：指针 A , B 同时指向「第一个公共节点」`node` 。**
2. **若两链表无公共尾部 (即 c=0 ) ：指针 A , B 同时指向`null` 。**

```C++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *A = headA, *B = headB;
        while (A != B) {
            A = A != nullptr ? A->next : headB;
            B = B != nullptr ? B->next : headA;
        }
        return A;
    }
};
```



# **4. 深度优先搜索(DFS)**

## **面试题27：二叉树的镜像**

**请完成一个函数，输入一个二叉树，该函数输出它的镜像。**

**<img src="/assets/blog_res/2022-03-21-%E5%89%91%E6%8C%87offer.assets/image-20211118202709446.png" alt="image-20211118202709446" style="zoom: 67%;" />**

**示例：**

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

**方法一：递归法**

**思路：用temp暂存左节点，让root的左子节点等于root的右子节点，让root的右子节点等于root的左子节点。**

```c++
class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root) {
        if(root==nullptr) return nullptr;
        TreeNode* temp = root->left;
        root->left = mirrorTree(root->right);
        root->right = mirrorTree(temp);
        return root;
    }
};
```

**方法二：辅助栈（或队列）**

**思路：先把root存入栈中，弹出，再将root的左右节点放入栈中，交换左右节点。**

```c++
class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root) {
        if(root==nullptr) return nullptr;
        stack<TreeNode*>stack;
        stack.push(root);//把root存入栈中
        while(!stack.empty())
        {
            TreeNode* Node = stack.top();
            stack.pop();
            if(Node->left!=nullptr) stack.push(Node->left);
            if(Node->right!=nullptr) stack.push(Node->right);
            TreeNode* temp = Node->left;
            Node->left = Node->right;
            Node->right = temp;
        }
        return root;
    }
};
```

## **面试题28：对称的二叉树**

**请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。**

**例如，二叉树 [1,2,2,3,4,4,3] 是对称的。**

**![image-20211118210801583](/assets/blog_res/2022-03-21-%E5%89%91%E6%8C%87offer.assets/image-20211118210801583.png)**

**方法一：遍历+递归**

**思路：前序算法先遍历左子树，再遍历右子树。定义一种遍历算法，先遍历右子树，再遍历左子树。判断这两个是否相等。**

```c++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        return Symmetric(root,root);
    }
private:
    bool Symmetric(TreeNode* root1,TreeNode* root2)
    {
        //如果都为空，返回true
        if(root1==nullptr&&root2==nullptr) return true;
        //如果只有一个为空，返回false
        if(root1==nullptr||root2==nullptr) return false;
        //如果两个节点的val不相等，返回false
        if(root1->val!=root2->val) return false;
        return Symmetric(root1->left,root2->right)&&Symmetric(root2->right,root1->left);
    }
};
```

**方法二：递归**

**思路：对称二叉树满足**

**L.val=R.val ：即此两对称节点值相等。**
**L.left.val = R.right.valL.left.val=R.right.val ：即 LL 的 左子节点 和 RR 的 右子节点 对称；**
**L.right.val = R.left.valL.right.val=R.left.val ：即 LL 的 右子节点 和 RR 的 左子节点 对称。**

```c++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        return root==nullptr ? true:recur(root->left,root->right);
    }
    bool recur(TreeNode* L,TreeNode* R)
    {
        if(L==nullptr&&R==nullptr)return true;
        if(L==nullptr||R==nullptr||L->val!=R->val) return false;
        return recur(L->left,R->right)&&recur(L->right,R->left);
    }

};
```

## **面试题55-1：二叉树的深度**

**输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。**

**方法一：后序遍历(DFS)**

**树的后序遍历/深度优先搜索往往利用递归和栈实现。**

**此树的深度 等于 左子树的深度与 右子树的深度中的 最大值 +1 。**

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root==nullptr) return 0;
        return max(maxDepth(root->left),maxDepth(root->right))+1;
    }
};
```

**方法二：层序遍历(BFS)**

**树的层序遍历 / 广度优先搜索往往利用 队列 实现。**

**每遍历一层，则计数器 +1+1 ，直到遍历完成，则可得到树的深度。**

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root==nullptr) return 0;
        queue<TreeNode*>queue;
        queue.push(root);
        int res=0;
        while(!queue.empty())
        {
            res++;
            int n = queue.size();
            for(int i=0;i<n;i++)
            {
                TreeNode* Node = queue.front();
                queue.pop();
                if(Node->left!=nullptr) queue.push(Node->left);
                if(Node->right!=nullptr) queue.push(Node->right);
            }
        }
        return res;
    }
};
```

# **5. 数组与矩阵**

## **03.数组中重复的数字**

**在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。**

**示例1：**

```
输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 
```

**思路：**

**方法一：哈希表/Set**

**一开始想要暴力解答，但是时间复杂度到了O($n^2$)，所以想到使用哈希表set，用空间换时间。时间复杂度O($n$)，空间复杂度O($n$)**

```c++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        unordered_map<int, bool> map;
        for(int num : nums) {
            if(map[num]) return num;
            map[num] = true;
        }
        return -1;
    }
};
```

**方法二：原地交换**

**当面试官要求时间复杂度O(n)，空间复杂度O(1)时，就不能使用排序的方法，也不能使用额外的标记数组。**

**根据题目条件，`在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内`，说明数组元素的索引和值是一对多的关系。**

**因此，可遍历数组并通过交换操作，使元素的 索引 与 值 一一对应（即`nums[i] = i `）。因而，就能通过索引映射对应的值，起到与字典等价的作用。**

```c++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        int i = 0;
        while(i < nums.size()) {
            if(nums[i] == i) {
                i++;
                continue;
            }
            if(nums[nums[i]] == nums[i])
                return nums[i];
            swap(nums[i],nums[nums[i]]);
        }
        return -1;
    }
};
```

## **04. 二维数组的查找**

**在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。**

**示例：**

**现有矩阵 matrix 如下：**

```
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

给定 target = `5`，返回 `true`。
给定 target = `20`，返回 `false`。
```

**思路：**

**将矩阵逆时针旋转 45° ，并将其转化为图形式，发现其类似于 二叉搜索树 ，即对于每个元素，其左分支元素更小、右分支元素更大。**

**“根节点” 对应的是矩阵的 “左下角” 和 “右上角” 元素，本文称之为 标志数 ，以 `matrix` 中的 左下角元素 为标志数 `flag` ，则有:**

**若 flag > target ，则 target 一定在 flag 所在 行的上方 ，即 flag 所在行可被消去。**
**若 flag < target ，则 target 一定在 flag 所在 列的右方 ，即 flag 所在列可被消去。**

```c++
class Solution {
public:
    bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {
        int i = matrix.size() - 1, j = 0;
        while(i >= 0 && j < matrix[0].size())
        {
            if(matrix[i][j] > target) i--;
            else if(matrix[i][j] < target) j++;
            else return true;
        }
        return false;
    }
};
```

## **05. 替换空格**

**请实现一个函数，把字符串 `s` 中的每个空格替换成"%20"。**

 **示例：**

```
输入：s = "We are happy."
输出："We%20are%20happy."
```

**思路：**

**方法一：遍历添加**

**创建一个字符串，遍历字符串s，然后遇到空格就替换。时间复杂度O(n)，空间复杂度O(n)。**

```c++
class Solution {
public:
    string replaceSpace(string s) {     //字符数组
        string array;   //存储结果
        
        for(auto &c : s){   //遍历原字符串
            if(c == ' '){
                array.push_back('%');
                array.push_back('2');
                array.push_back('0');
            }
            else{
                array.push_back(c);
            }
        }
        return array;
    }
};
```

**方法二：原地修改**

**注意到替换后，字符串长度变了。一个空格替换为%20，需要扩充原字符串s的长度。**

**先统计空格数量，确定新字符串的长度。倒序遍历修改：`i` 指向原字符串尾部元素， `j` 指向新字符串尾部元素；当 `i = j` 时跳出（代表左方已没有空格，无需继续遍历）。**

**时间复杂度O(n)，空间复杂度O(1)。**

```c++
class Solution {
public:
    string replaceSpace(string s) {
        int count = 0, len = s.size();
        // 统计空格数量
        for (char c : s) {
            if (c == ' ') count++;
        }
        // 修改 s 长度
        s.resize(len + 2 * count);
        // 倒序遍历修改
        for(int i = len - 1, j = s.size() - 1; i < j; i--, j--) {
            if (s[i] != ' ')
                s[j] = s[i];
            else {
                s[j - 2] = '%';
                s[j - 1] = '2';
                s[j] = '0';
                j -= 2;
            }
        }
        return s;
    }
};
```

## **29. 顺时针打印矩阵**

**输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。**

 **示例1：**

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

**示例2：**

```
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```

**思路：**

**考虑设定矩阵的“左、上、右、下”四个边界，模拟以上矩阵遍历顺序。**

**当 `matrix` 为空时，直接返回空列表 `[]` 即可，矩阵 左、右、上、下 四个边界 `l` , `r` , `t` , `b` ，用于打印的结果列表 `res` 。 “从左向右、从上向下、从右向左、从下向上” 四个方向循环，每个方向打印中做以下三件事：**

1. **根据边界打印，即将元素按顺序添加至列表 `res` 尾部；**
2. **边界向内收缩 11 （代表已被打印）；**
3. **判断是否打印完毕（边界是否相遇），若打印完毕则跳出。**

**从左往右，上边界下移，也就是$l++$；**

**从上往下，右边界左移，也就是$r--$;**

**从右往左，下边界上移，也就是$b--$；**

**从下往上，左边界右移，也就是$l++$。**

**时间复杂度O(MN)，空间复杂度O(1)。**

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if(matrix.empty()) return {};
        int l=0,r=matrix[0].size()-1,t=0,b=matrix.size()-1;
        vector<int>res;
        while(true)
        {
            //从左往右
            for(int i=l;i<=r;i++)
            {
                res.push_back(matrix[t][i]);
            }
            if(++t>b) //++t > b 等价于先给 t 自增 1 ，再判断 t > b 逻辑表达式
            {
                break;
            }
            //从上往下
            for(int i=t;i<=b;i++)
            {
                res.push_back(matrix[i][r]);
            }
            if(--r<l)
            {
                break;
            }
            //从右往左
            for(int i=r;i>=l;i--)
            {
                res.push_back(matrix[b][i]);
            }
            if(--b<t)
            {
                break;
            }
            //从下往上
            for(int i=b;i>=t;i--)
            {
                res.push_back(matrix[i][l]);
            }
            if(++l>r)
            {
                break;
            }
        }
        return res;
    }
};
```

# **6. 双指针**

## **57.1 和为s的两个数字**

**输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。**

**示例：**

```
输入：nums = [2,7,11,15], target = 9
输出：[2,7] 或者 [7,2]
```

**使用双指针，一个指针指向元素较小的值，一个指针指向元素较大的值。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。**

- **如果两个指针指向元素的和 sum == target，那么这两个元素即为所求。**
- **如果 sum > target，移动较大的元素，使 sum 变小一些；**
- **如果 sum < target，移动较小的元素，使 sum 变大一些。**

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int i=0,j=nums.size()-1;
        vector<int>res;
        while(i<j){
            int sum = nums[i]+nums[j];
            if(sum<target){
                i++;
            }
            else if(sum>target){
                j--;
            }
            else{
                res.push_back(nums[i]);
                res.push_back(nums[j]);
                return res;
            }
        }
        return res;
    }
};
```

## **57.2 和为s的连续正数序列**

**输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。**

**序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。**

**示例：**

```
输入：target = 9
输出：[[2,3,4],[4,5]]
```

**方法一：滑动窗口**

**设连续正整数序列的左边界 ii 和右边界 jj ，则可构建滑动窗口从左向右滑动。循环中，每轮判断滑动窗口内元素和与目标值 targettarget 的大小关系，若相等则记录结果，若大于 targettarget 则移动左边界 ii （以减小窗口内的元素和），若小于 targettarget 则移动右边界 jj （以增大窗口内的元素和）。**

```c++
class Solution {
public:
    vector<vector<int>> findContinuousSequence(int target) {
        int i = 1, j = 2, s = 3;
        vector<vector<int>> res;
        while(i < j) {
            if(s == target) {
                vector<int> ans;
                for(int k = i; k <= j; k++)
                    ans.push_back(k);
                res.push_back(ans);
            }
            if(s >= target) {
                s -= i;
                i++;
            } else {
                j++;
                s += j;
            }
        }
        return res;
    }
};
```

**方法二：求和公式**

**设左边界$i$、右边界$j$，此序列的元素和$target$等于元素的平均值$\frac {i+j}2$乘以元素数量$(j-i+1)$。当我们知道左边界和target，就能够确定有边界。**
$$
j = \frac {-1+\sqrt{1+4(2×target+i^2-i)}}2
$$

```c++
class Solution {
public:
    vector<vector<int>> findContinuousSequence(int target) {
        int i = 1;
        double j = 2.0;
        vector<vector<int>> res;
        while(i < j) {
            //计算公式中 i^2项可能超过 int 类型取值范围，因此在C++中需要转化成 long 类型。
            j = (-1 + sqrt(1 + 4 * (2 * target + (long) i * i - i))) / 2;
            if(i < j && j == (int)j) {
                vector<int> ans;
                for(int k = i; k <= (int)j; k++)
                    ans.push_back(k);
                res.push_back(ans);
            }
            i++;
        }
        return res;
    }
};
```

## **58.1 翻转单词顺序**

**输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串"I am a student. "，则输出"student. a am I"。**

**示例：**

```
输入: "  hello world!  "
输出: "world! hello"
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。

输入: "a good   example"
输出: "example good a"
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。
```

**方法一：双指针**

**倒序遍历字符串 s ，记录单词左右索引边界 i , j ；**
**每确定一个单词的边界，则将其添加至单词列表 res ；**
**最终，将单词列表拼接为字符串，并返回即可。**

**补充知识：**

**`string substr (size_t pos = 0, size_t len = npos) const;`**

**返回一个新建的 初始化为string对象的子串的拷贝string对象。子串是，在字符位置pos开始，跨越len个字符（或直到字符串的结尾，以先到者为准）对象的部分。**

```c++
class Solution {
public:
    string reverseWords(string s) {
        string res;
        int n = s.size();
        if(n == 0) return res;
        int right = n - 1;
        while(right >= 0){
            //从后往前寻找第一字符
            while(right >= 0 && s[right] == ' ') right--;
            if(right < 0) break;

            //从后往前寻找第一个空格
            int left = right;
            while( left >= 0 && s[left] != ' ' ) left--;

            //添加单词到结果
            res.append(s.substr(left + 1, right - left));
            res.append(" ");

            //继续往前分割单词
            right = left;
        }
        //去除最后一个字符空格
        if (!res.empty()) res.pop_back();
        return res;
    }
};
```

**方法二：分割+倒序**

**补充知识：`stringstream`：https://blog.csdn.net/liitdar/article/details/82598039**

**`getline(cin, inputLine)`：把输入流赋值到inputline中。**

```c++
class Solution {
public:
    string reverseWords(string s) {
        string res;
        stringstream ss(s);
        string str;
        while(getline(ss,str,' ')){
            if(!str.empty()){
                res = str+' '+res;
            }
        }
        res.pop_back();
        return res;
    }
};
```

## **58.2 左旋转字符串**

**字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。**

**示例：**

```
输入: s = "abcdefg", k = 2
输出: "cdefgab"
```

**方法一：三次反转**

**先将 "abc" 和 "XYZdef" 分别翻转，得到 "cbafedZYX"，然后再把整个字符串翻转得到 "XYZdefabc"。**

```c++
class Solution {
public:
    string reverseLeftWords(string s, int n) {
        reverse(s.begin(),s.begin()+n);
        reverse(s.begin()+n,s.end());
        reverse(s.begin(),s.end());
        return s;
    }
};
```

**方法二：将前k个字符插入字符串，然后将前k个删除即可**

**补充知识：c++ string的erase删除方法**

**`basic_string & erase(size_type pos=0, size_type n=npos);`从给定起始位置`pos`处开始删除, 要删除字符的长度为`n`, 返回值修改后的string对象引用。https://blog.csdn.net/u010472607/article/details/80431604**

```c++
class Solution {
public:
    string reverseLeftWords(string s, int n) {
        for(int i=0;i<n;i++){
            s.push_back(s[i]);
        }
        s.erase(0,n);
        return s;
    }
};
```

# **7. 树**

## **▲07. 重建二叉树**

**输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。**

**假设输入的前序遍历和中序遍历的结果中都不含重复的数字。**

**示例：**

**<img src="/assets/blog_res/2022-03-21-%E5%89%91%E6%8C%87offer.assets/tree.jpg" alt="img" style="zoom: 67%;" />**

```
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
```

**方法一：递归**

**前序遍历：[根节点，[左子树前序遍历结果]，[右子树前序遍历结果]]**

**中序遍历：[[左子树的中序遍历结果]，根节点，[右子树的中序遍历结果]]**

**后序遍历：[[左子树的后序遍历结果]，[右子树的中序遍历结果]，根节点]**

**用前序遍历中找到根节点的的值，再来中序遍历中找到根节点的位置，从而划分左右子树。**

```c++
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        this->preorder = preorder;
        for(int i=0;i<inorder.size();i++){
            dic[inorder[i]]=i;
        }
        return recur(0,0,inorder.size()-1);
    }
private:
    //键值为节点的值，值为中序遍历中的索引
    unordered_map<int,int>dic;
    vector<int>preorder;
    TreeNode *recur(int root,int left,int right){
        if(left>right) return nullptr;//递归终止
        TreeNode *node = new TreeNode(preorder[root]);
        //找到根节点在中序中的索引
        int idx = dic[preorder[root]];
        //左子树递归，传递的三个参数为
        //左子树前序遍历根节点索引，左子树的左边界，左子树右边界
        node->left = recur(root+1,left,idx-1);
        //右子树前序遍历根节点索引：根节点索引+左子树长度+1
        node->right = recur(root+idx-left+1,idx+1,right);
        return node;
    }
};
```

**方法二：迭代**

**前序遍历，从根节点`root`开始，只要有左子节点，就一直会往左下方走，直到最左下角。 而中序遍历，是从最左下角往上（示例中的4-5-8-9-3），如果碰到节点有右子节点，则会转向（示例中的8-10）。**

**因此，代码中的`if`块是用前序数组一直构建左子树，如果碰到了`inorder[inorderIndex]`，表示到了左下角，这时就需要往上走并处理右子树，也就是`while`代码块。**

```c++
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if(!preorder.size()){   //判断是否为空
            return nullptr;
        }
        TreeNode* root = new TreeNode(preorder[0]); //先序的首为根节点
        stack<TreeNode*> stk;   //建立栈
        stk.push(root); //根节点入栈
        int inorderIndex = 0;   //扫描中序的指针
        for(int i = 1; i < preorder.size(); i++){   //从先序遍历开始逐个遍历
            TreeNode *node = stk.top();
            if(node->val != inorder[inorderIndex]){ //栈顶元素的值与中序遍历当前所指的元素值不等
                node->left = new TreeNode(preorder[i]); //前序遍历中处在栈顶元素位置后一位的元素是栈顶元素的左子树
                stk.push(node->left);   //栈顶元素左子树节点入栈
            }else{  //栈顶元素的值与中序遍历当前所指的元素值相等,栈顶即为最左下角的树节点
                while(!stk.empty() && stk.top()->val == inorder[inorderIndex]){ //while循环向上返回，寻找位置进行右子树的重建
                    node = stk.top();   //指针向右扫描中序遍历
                    stk.pop();  //栈中所有与当前指针所指元素值相等的节点出栈
                    inorderIndex++;
                }
                node->right = new TreeNode(preorder[i]);    // 循环结束后，node所指栈顶元素即是需要重建右子树的节点
                stk.push(node->right);
            }
        }
        return root;    
    }
};
```

# **8. 贪心思想**

## **14. 剪绳子**

**给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。**

**示例：**

```
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1
```

**尽可能得多剪长度为 3 的绳子，并且不允许有长度为 1 的绳子出现。如果出现了，就从已经切好长度为 3 的绳子中拿出一段与长度为 1 的绳子重新组合，把它们切成两段长度为 2 的绳子。以下为证明过程。**

**将绳子拆成 1 和 n-1，则 1(n-1)-n=-1<0，即拆开后的乘积一定更小，所以不能出现长度为 1 的绳子。**

**将绳子拆成 2 和 n-2，则 2(n-2)-n = n-4，在 n>=4 时这样拆开能得到的乘积会比不拆更大。**

**将绳子拆成 3 和 n-3，则 3(n-3)-n = 2n-9，在 n>=5 时效果更好。**

**将绳子拆成 4 和 n-4，因为 4=2*2，因此效果和拆成 2 一样。**

**将绳子拆成 5 和 n-5，因为 5=2+3，而 5<2*3，所以不能出现 5 的绳子，而是尽可能拆成 2 和 3。**

**将绳子拆成 6 和 n-6，因为 6=3+3，而 6<3*3，所以不能出现 6 的绳子，而是拆成 3 和 3。这里 6 同样可以拆成 6=2+2+2，但是 3(n - 3) - 2(n - 2) = n - 5 >= 0，在 n>=5 的情况下将绳子拆成 3 比拆成 2 效果更好。**

**继续拆成更大的绳子可以发现都比拆成 2 和 3 的效果更差，因此我们只考虑将绳子拆成 2 和 3，并且优先拆成 3，当拆到绳子长度 n 等于 4 时，也就是出现 3+1，此时只能拆成 2+2。**

```c++
class Solution {
public:
    int cuttingRope(int n) {
        if(n<=3){
            return n-1;
        }
        int a=n/3,b=n%3;
        if(b==0) return pow(3,a);
        if(b==1) return pow(3,a-1)*4;
        return pow(3,a)*2;
    }
};
```

**补充知识：**

**大数求余问题：**

1. **循环取余：**
   $$
   x^a \odot p=[(x^{a-1}\odot p)(x\odot p)]\odot p=[(x^{a-1}\odot p)x]\odot p
   $$

2. **快速幂取余**

   **<img src="C:\Users\WJL\AppData\Roaming\Typora\typora-user-images\image-20220224144216213.png" alt="image-20220224144216213" style="zoom: 67%;" />**

```c++
// 取余
class Solution {
public:
    int cuttingRope(int n) {
        if(n<=3) return n-1;
        int a=n/3-1,b=n%3,p=1e9+7;
        long rem = 1,x=3;
        while(a>0){
            //奇数
            if(a%2!=0){
                rem = rem*x%p;
            }
            x = x*x%p;
            a/=2;
        }

        if(b==0) return rem*3%p;
        if(b==1) return rem*4%p;
        return rem*6%p;
    }
};
```

## **63. 股票的最大利润**

**假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？**

**示例：**

```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
```

**思路：贪心**

**使用贪心策略，假设第 i 轮进行卖出操作，买入操作价格应该在 i 之前并且价格最低。因此在遍历数组时记录当前最低的买入价格，并且尝试将每个位置都作为卖出价格，取收益最大的即可。**

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int inf = 1e9;
        int minPrice = inf,maxProfit = 0;
        for(int price:prices){
            maxProfit = max(maxProfit,price-minPrice);
            minPrice = min(minPrice,price);
        }
        return maxProfit;
    }
};
```

# 9. 二分查找

## 11. 旋转数组的最小数字

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。

给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为1。  

**示例**：

```
输入：[3,4,5,1,2]
输出：1
```

**思路**：二分查找，将复杂度降为log，用中间的值与右端相比。

```c++
class Solution {
public:
    int minArray(vector<int>& numbers) {
        int i=0,j=numbers.size()-1;
        while(i<j){
            int m = (i+j)/2;
            if(numbers[m]>numbers[j]) i = m+1;
            else if(numbers[m]<numbers[j]) j = m;
            else j--;
        }
        return numbers[i];
    }
};
```

## 53.1 在排序数组中查找数字 I

统计一个数字在**排序**数组中出现的次数。

**示例：**

```
输入: nums = [5,7,7,8,8,10], target = 8
输出: 2
```

思路：使用二分查找，找出target的左右边界。

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        //转换为找target和target-1的有边界
        return helper(nums,target)-helper(nums,target-1);
    }
private: 
    int helper(vector<int>nums,int target){
        int i=0,j=nums.size()-1;
        while(i<=j){
            int m = (i+j)/2;
            if(nums[m]<=target) i = m+1;
            else j = m-1;
        }
        return i;
    }
};
```

## 53.2 0~n-1中缺失的数字

一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。

**示例：**

```
输入: [0,1,3]
输出: 2
```

**思路**：用二分查找，当$nums[i]=i$时，缺失值在右子数组，当$nums[i]\ne i$时，缺失值在左子数组。

```c++
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int i=0,j=nums.size()-1;
        while(i<=j){
            int m = (i+j)/2;
            if(nums[m]==m) i = m+1;
            else j = m-1;
        }
        return i;
    }
};
```

# 10. 分冶

## 16. 数值的整数次方

实现 pow(x,n)，即计算 x 的 n 次幂函数（即$x^n$）。不得使用库函数，同时不需要考虑大数问题。

 **示例：**

```
输入：x = 2.00000, n = 10
输出：1024.00000
```

**思路：**

快速幂，分n的奇偶，使用``n&1==1`来判断奇偶，为真则为奇数，否则为假。使用右移运算符替代`n/=2`。

```c++
class Solution {
public:
    double myPow(double x, int n) {
        if(x==0) return 0;
        double res = 1;
        long b = n;
        if(b<0){
            x = 1/x;
            b = -b;
        }
        while(b>0){
            if(b&1==1) res = res*x;
            x*=x;
            b>>=1;
        }
        return res;
    }
};
```

# ▲11. 搜索

## 12. 矩阵中的路径

给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

例如，在下面的 3×4 的矩阵中包含单词 "ABCCED"（单词中的字母已标出）。

![img](/assets/blog_res/2022-03-21-%E5%89%91%E6%8C%87offer.assets/word2.jpg)

**示例 1：**

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```

**思路**：深度优先搜索(dfs)+剪枝，需要上下左右进行搜索，用到**递归**。

```c++
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        row = board.size();
        col = board[0].size();
        for(int i=0;i<row;i++){
            for(int j=0;j<col;j++){
                if(dfs(board,word,i,j,0)) return true;
            }
        }
        return false;

    }
private:
    int row,col;
    bool dfs(vector<vector<char>>& board,string word,int i,int j,int k){
        if(i>=row||j>=col||i<0||j<0||board[i][j]!=word[k]) return false;
        if(k==word.size()-1) return true;
        char temp = board[i][j];
        board[i][j] = '\0';
        int dx[4] = {-1,0,1,0},dy[4] = {0,1,0,-1};//顺时针
        for(int m = 0;m<4;m++){
            if(dfs(board,word,i+dx[m],j+dy[m],k+1)) return true;
        }
        board[i][j] = temp;
        return false;
    }
};
```

## 13. 机器人的运动范围

地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

**示例：**

```
输入：m = 2, n = 3, k = 1
输出：3
```

**方法一**：深度优先搜索dfs

计算数位和时，发现规律：当$(x+1)\odot 10=0$时，$s_{x+1}=s_x-8$，当$(x+1)\odot 10 \ne0$时，$s_{x+1}=s_x+1$

搜索时，只需要向下和向右搜索。

```c++
class Solution {
public:
    int movingCount(int m, int n, int k) {
        vector<vector<bool>>visited(m,vector<bool>(n,0));
        return dfs(0,0,0,0,visited,m,n,k);
    }
private:
    //i,j为坐标索引，si、sj为数位和
    int dfs(int i,int j,int si,int sj,vector<vector<bool>> &visited,int m,int n,int k){
        if(i>=m||j>=n||(si+sj)>k||visited[i][j]) return 0;
        visited[i][j] = true;
        return 1+dfs(i+1,j,(i+1)%10!=0 ? si+1:si-8,sj,visited,m,n,k)+
            dfs(i,j+1,si,(j+1)%10!=0 ? sj+1:sj-8,visited,m,n,k);
    }
};
```

**方法二：广度优先遍历BFS**

**BFS/DFS** ： 两者目标都是遍历整个矩阵，不同点在于搜索顺序不同。DFS 是朝一个方向走到底，再回退，以此类推；BFS 则是按照“平推”的方式向前搜索。
**BFS 实现**： 通常利用队列实现广度优先遍历。

```c++
class Solution {
public:
    int movingCount(int m, int n, int k) {
        vector<vector<bool>>visited(m,vector<bool>(n,0));
        int res = 0;
        queue<vector<int>>q;
        //四个0分别表示：行，列，行位数和，列位数和
        q.push({0,0,0,0});
        while(!q.empty()){
            vector<int>x = q.front();
            q.pop();
            int i=x[0],j=x[1],si=x[2],sj=x[3];
            if(i>=m||j>=n||(si+sj)>k||visited[i][j]) continue;
            visited[i][j] = true;
            res++;
            q.push({i+1,j,(i+1)%10!=0?si+1:si-8,sj});
            q.push({i,j+1,si,(j+1)%10!=0?sj+1:sj-8});
        }
        return res;
    }
};
```

## 38. 字符串的排列

输入一个字符串，打印出该字符串中字符的所有排列。

你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。

**示例:**

```
输入：s = "abc"
输出：["abc","acb","bac","bca","cab","cba"]
```

**思路**：首先要把字符串全排列，然后对元素进行去重

```c++
class Solution {
public:
    vector<string> permutation(string s) {
        dfs(s,0);
        return res;
    }
private:
    vector<string>res;
    void dfs(string s,int x){
        if(x==s.size()-1){
            res.push_back(s);
        }
        set<char>st;
        for(int i=x;i<s.size();i++){
            if(st.find(s[i])!=st.end()) continue;
            st.insert(s[i]);
            swap(s[i],s[x]);
            dfs(s,x+1);
            swap(s[i],s[x]);
        }     
    }
};
```

# 12. 排序

## 21. 调整数组顺序使奇数位于偶数前面

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。

**示例：**

```
输入：nums = [1,2,3,4]
输出：[1,3,2,4] 
注：[3,1,2,4] 也是正确的答案之一。
```

**思路：**使用双指针可将空间复杂度降为O(1)

**补充知识**：vector<int>a,vector<int>b，将b插入到a尾部，使用insert命令。

`a.insert(a.end(),b.begin(),b.end())`

```c++
class Solution {
public:
    vector<int> exchange(vector<int>& nums) {
        //双指针
        //i从左到右寻找偶数，j从右到左寻找奇数
        int i=0,j=nums.size()-1;
        while(i<j){
            while(i<j&&(nums[i]&1)==1) i++;
            while(i<j&&(nums[j]&1)==0) j--;
            swap(nums[i],nums[j]);
        }
        return nums;
    }
};
```

## 45. 把数组排成最小的数

输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。

**示例 1:**

```
输入: [10,2]
输出: "102"
```

**思路**：快速排序，在比较两个字符串 S1 和 S2 的大小时，应该比较的是 S1+S2 和 S2+S1 的大小，如果 S1+S2 < S2+S1，那么应该把 S1 排在前面，否则应该把 S2 排在前面。

**补充知识**：[快速排序](https://blog.csdn.net/qq_28584889/article/details/88136498)，快速排序有固定的模板，在搜索时要先从右往左搜索，否则会出错。[sort排序](http://c.biancheng.net/view/7457.html)

```c++
class Solution {
public:
    string minNumber(vector<int>& nums) {
        vector<string>str;
        string res;
        for(int i=0;i<nums.size();i++){
            str.push_back(to_string(nums[i]));
        }
        quickSort(str,0,str.size()-1);
        for(string s:str){
            res.append(s);
        }
        return res;
    }
private:
    void quickSort(vector<string> &str,int l,int r){
        if(l>=r) return;
        int i=l,j=r;
        while(i<j){
            //小的都在左边，大的都在右边
            //先从右往左搜索，再从左往右            
            while(i<j&&(str[j]+str[l]>=str[l]+str[j])) j--;
            while(i<j&&(str[i]+str[l]<=str[l]+str[i])) i++;
            swap(str[i],str[j]);
        }
        swap(str[i],str[l]);
        quickSort(str,l,i-1);
        quickSort(str,i+1,r);
    }
};
```

```c++
//使用自带的sort函数
class Solution {
public:
    string minNumber(vector<int>& nums) {
        vector<string>str;
        string res;
        for(int i=0;i<nums.size();i++){
            str.push_back(to_string(nums[i]));
        }
        sort(str.begin(),str.end(),[](string &x,string &y){return x+y<y+x;});
        for(string s:str){
            res.append(s);
        }
        return res;
    }
};
```

## 51. 数组中的逆序对

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

 **示例 1:**

```
输入: [7,5,6,4]
输出: 5
```

**方法一：归并排序**

步骤：

分解：待排序的区间为 $[l,r]$，令$m=\frac {l+r}2$，我们把$[l,r]$分成$[l,m]$和$[m+1,r]$

解决：使用归并排序递归地排序两个子序列

合并：把两个已经排好序的子序列$[l,m]$和$[m+1,r]$合并起来。

```c++
class Solution {
public:
    int mergeSort(vector<int>&nums,vector<int>&temp,int l,int r){
        if(l>=r) return 0;
        int m = (l+r)/2;
        //贡献的个数
        int inv_count = mergeSort(nums,temp,l,m) + mergeSort(nums,temp,m+1,r);
        int i=l,j=m+1,pos=l;
        while(i<=m&&j<=r){
            //nums[i]较小，就放入temp数组，并计算它贡献的个数
            if(nums[i]<=nums[j]){
                temp[pos] = nums[i];
                ++i;
                inv_count += (j-(m+1));
            }
            else{
                temp[pos] = nums[j];
                ++j;
            }
            ++pos;
        }
        //统计子数组遍历完之后，剩下的贡献度
        for(int k=i;k<=m;k++){
            temp[pos++] = nums[k];
            inv_count += (j-(m+1));
        }
        for(int k=j;k<=r;k++){
            temp[pos++] = nums[k];
        }
        //将temp复制到nums
        copy(temp.begin()+l,temp.begin()+r+1,nums.begin()+l);
        return inv_count;
    }
    int reversePairs(vector<int>& nums) {
        int n = nums.size();
        vector<int>temp(n);
        return mergeSort(nums,temp,0,n-1);      
    }
};
```

# 13. 动态规划

## 10.1 斐波那契数列

写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：

```
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
```

斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

 **示例：**

```
输入：n = 5
输出：5
```

**方法一：动态规划**，时间复杂度O(n)，空间复杂度O(1)

**思路**：刚开始用递归法，但是递归法会重复计算一些子问题。例如，计算 f(4) 需要计算 f(3) 和 f(2)，计算 f(3) 需要计算 f(2) 和 f(1)，可以看到 f(2) 被重复计算了，递归法超时。使用动态规划，初始化三个整形变量 `sum`, `a`, `b` ，利用辅助变量 sum 使 a, b两数字交替前进。

```c++
class Solution {
public:
    int fib(int n) {
        int p=1e9+7;
        int a=0,b=1,sum;
        for(int i=0;i<n;i++){
            sum = (a+b)%p;
            a = b;
            b = sum;
        }
        return a;
    }
};
```

**方法二：矩阵快速幂**，时间复杂度O(logn)，空间复杂度O(1)

<img src="/assets/blog_res/2022-03-21-%E5%89%91%E6%8C%87offer.assets/image-20220225193913145.png" alt="image-20220225193913145" style="zoom:67%;" />

```c++
class Solution {
public:
    int p=1e9+7;
    int fib(int n) {       
        if(n<2) return n;
        vector<vector<long>>q{{1,1},{1,0}};
        vector<vector<long>>res = pow(q,n-1);
        return res[0][0];
    }

    //矩阵的快速幂
    vector<vector<long>> pow(vector<vector<long>>&a,int n){
        //新建一个单位矩阵
        vector<vector<long>>ret{{1,0},{0,1}};
        while(n>0){
            if(n&1) ret = multiply(ret,a);
            n>>=1;
            a = multiply(a,a);
        }
        return ret;
    }
    //矩阵乘法
    vector<vector<long>> multiply(vector<vector<long>>&a,vector<vector<long>>&b){
        vector<vector<long>>c{{0,0},{0,0}};
        for(int i=0;i<2;i++){
            for(int j=0;j<2;j++){
                c[i][j] = (a[i][0]*b[0][j]+a[i][1]*b[1][j])%p;
            }
        }
        return c;
    }
};
```

## 10.2 矩形覆盖

我们可以用 2×1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2×1 的小矩形无重叠地覆盖一个 2*n 的大矩形，从同一个方向看总共有多少种不同的方法？

![img](/assets/blog_res/2022-03-21-%E5%89%91%E6%8C%87offer.assets/59_1603852524038_7FBC41C976CACE07CB222C3B890A0995.png)

**示例：**

```
输入：4
返回值：5
```

**思路**：计算前几个的值，找规律。$f(n)=f(n-1)+f(n-2)$

```c++
class Solution {
public:
    int rectCover(int number) {
        if(number==0) return 0;
        int a=1,b=2,sum;
        for(int i=1;i<number;i++){
            sum = a+b;
            a = b;
            b = sum;
        }
        return a;
    }
};
```

## 10.3 青蛙跳台阶问题

一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

**示例：**

```
输入：n = 2
输出：2
```

**思路**：当青蛙跳到最后一步时，有两种情况：距离2阶和距离1阶。因此有的跳法为$f(n)=f(n-1)+f(n-2)$，可转化为斐波那契数列。

```c++
class Solution {
public:
    int numWays(int n) {
        int a=1,b=1,sum;
        int mod = 1e9+7;
        for(int i=0;i<n;i++){
            sum = (a+b)%mod;
            a = b;
            b = sum;
        }
        return a;
    }
};
```

## 10.4 跳台阶扩展问题

一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶(n为正整数)总共有多少种跳法。

示例：

```
输入：3
返回值：4
```

**思路**：$f(n-1)=f(n-2)+f(n-3)+...+f(0)$

$f(n)=f(n-1)+f(n-2)+...+f(0)$，两式相减，得到$f(n)=2*f(n-1)$

```c++
class Solution {
public:
    int jumpFloorII(int number) {
        if(number==0||number==1) return 1;
        int a=1,b;
        for(int i=1;i<number;i++){
            b = a<<1;
            a = b;
        }
        return b;
    }
};
```

## 42. 连续子数组的最大和

输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。

**示例1:**

```
输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

**思路**：dp[0]=nums[0]，如果dp[i-1]>0，说明贡献度是正的，此时dp[i]=dp[i-1]+nums[i]，否则，dp[i] = nums[i]。

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int maxSum = nums[0];
        int former = 0;//储存dp[i-1]的值
        int cur = nums[0];//储存nums[i]
        for(int num:nums){
            //如果dp[i-1]>0，dp[i]就加上dp[i-1]
            cur = num;
            if(former>0) cur+=former;
            if(cur>maxSum) maxSum=cur;
            former = cur;
        }
        return maxSum;
    }
};
```

## 47. 礼物的最大价值

在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？

**示例 1:**

```
输入: 
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 12
解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物
```

**思路**：右下角的元素只能由左边和上边元素得来。因此，$f(i,j)=max(f(i-1,j),f(i,j-1))+grid(i,j)$，因此用动态规划，但是需要特殊考虑第一行和第一列的元素，因为只能从一个方向得来。为了减少内存的消耗，直接修改原数组，不新建dp数组。

```c++
class Solution {
public:
    int maxValue(vector<vector<int>>& grid) {
        int rows = grid.size(),cols = grid[0].size();
        //初始化第一行,因为第一行只能从左来
        for(int j=1;j<cols;j++){
            grid[0][j] += grid[0][j-1];
        }
        //初始化第一列，只能从上面来
        for(int i=1;i<rows;i++){
            grid[i][0]+=grid[i-1][0];
        }
        for(int i=1;i<rows;i++){
            for(int j=1;j<cols;j++){
                grid[i][j] = max(grid[i-1][j],grid[i][j-1]) + grid[i][j];
            }
        }
        //返回dp[m-1][n-1]
        return grid[rows-1][cols-1];
    }

};
```

## 48. 最长不含重复字符的子字符串

请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。

**示例 1:**

```
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**方法一：动态规划+哈希表**

最长不含重复字符的子字符串，如果用动态规划的方法，我们可以想到用dp[i]表示以第i个字符结尾的不含重复字符的子字符串的最大长度。
那么dp[i]如何通过前面的dp[i-1]递推得到呢？
可以从dp[0]开始，当字符串不为空时，一定可以得到dp[0] = 1。

以"abcabcbb"为例，dp[0] = 1;
循环判断当前字符是否在前面出现过，这里需要用到哈希表记录前面字符出现过的位置;
如果当前字符首次出现，那么dp[i] = dp[i - 1] + 1，比如dp[2] = dp[1] + 1, dp[3] = dp[2] + 1;
如果当前字符和哈希表记录的发生重复，计算当前字符位置与前面重复的字符位置的距离i - j，这里就要分两种情况：
(1)距离i - j > dp[i - 1],即前面重复的那个字符已经不在当前最长非重复子串里面了，比如"abcdeca"中的'a'，我们直接将当前长度在前面的基础上加一即可，因此dp[i] = dp[i - 1] + 1;
(2)i - j <= dp[i - 1], 即前面重复的那个字符包含在当前最长非重复子串里面了,如上面的'c'，我们当前新的最长非重复子串长度应该为i - j，即dp[i] = i - j;
5.更新哈希表
6.取dp中的最大值即为答案。

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s.size()==0) return 0;
        if(s.size()==1) return 1;
        unordered_map<char,int>map;
        int res = 0,temp=0;
        for(int j=0;j<s.size();j++){
            //如果未曾出现过，就自增1
            if(j!=0&&map.find(s[j])==map.end()){
                temp = temp+1;
            }
            //dp[0]=1
            else if(j==0){
                temp = 1;
            }
            else{
                int i=map[s[j]];              
                if(j-i>temp) temp = temp+1;
                else temp = j-i;
            }
            map[s[j]] = j;
            res = max(res,temp);
        }
        return res;

    }
};
```

**方法二：滑动窗口**

我们通过left和pos限定窗口的左右位置，确保窗口内的元素彼此不同。当窗口最右边的元素在窗口内存在了，我们就应该向右移动left，直到排除掉重复的元素。

- used数组用来表示哪些字符使用过了

- maxsub实时记录当前最长的不含重复字符的子字符串
- left和pos分别是窗口的左/右边界下标
- 迭代直到pos == s.size()

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        //maxsub为最长字串长度，left为左边界，pos为右边界
        int maxsub=0,left=0,pos=0;
        vector<bool>used(256,false);
        while(pos<s.size()){
            while(used[s[pos]]){
                used[s[left]] = false;
                left++;
            }
            maxsub = max(maxsub,pos-left+1);
            used[s[pos]] = true;
            pos++;          
        }
        return maxsub;
    }
};
```

## 49. 丑数

我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。

**示例:**

```
输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
```

**方法一：动态规划**
$$
dp[i]=min(dp[a]*2,dp[b]*3,dp[c]*5)
$$

```c++
class Solution {
public:
    int nthUglyNumber(int n) {
        int a=0,b=0,c=0;
        //dp保存丑数
        int dp[n];
        dp[0]=1;
        for(int i=1;i<n;i++){
            int n2 = dp[a]*2,n3 = dp[b]*3,n5=dp[c]*5;
            dp[i] = min(min(n2,n3),n5);
            if(dp[i]==n2)a++;
            if(dp[i]==n3)b++;
            if(dp[i]==n5)c++;
        }
        return dp[n-1];
    }
};
```

**方法二：小顶堆**

要得到从小到大的第 n 个丑数，可以使用最小堆实现。

初始时堆为空。首先将最小的丑数 1 加入堆。

每次取出堆顶元素 x，则 x 是堆中最小的丑数，由于 2x, 3x, 5x也是丑数，因此将 2x, 3x, 5x加入堆。

上述做法会导致堆中出现重复元素的情况。为了避免重复元素，可以使用哈希集合去重，避免相同元素多次加入堆。

在排除重复元素的情况下，第 n 次从最小堆中取出的元素即为第 n 个丑数。

**补充知识**：[优先队列](https://blog.csdn.net/weixin_36888577/article/details/79937886)

```c++
class Solution {
public:
    int nthUglyNumber(int n) {
        vector<int>factors = {2,3,5};
        //小顶堆，堆顶为最小元素，第n次pop的就为第n个丑数
        priority_queue<long,vector<long>,greater<long>>heap;
        //哈希集合去重
        unordered_set<long>seen;
        heap.push(1);
        seen.insert(1);
        int ugly = 0;
        for(int i=0;i<n;i++){
            long cur = heap.top();
            heap.pop();
            ugly = (int)cur;
            for(int factor:factors){
                long next = factor*cur;
                //set中没有，就插入
                if(!seen.count(next)){
                    seen.insert(next);
                    heap.push(next);
                }
            }
        }
        return ugly;
    }
};
```

## 60. n个骰子的点数

把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。

你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。

**示例：**

```
输入: 1
输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]
```

**思路**：动态规划，设置$f(n-1)$取$x$的概率为$f(n-1,x)$，那么$f(n)$取$x+1$的概率就为$f(n,x+1)=f(n-1,x)/6$，根据本条件进行递推。

```c++
class Solution {
public:
    vector<double> dicesProbability(int n) {
        //第1个骰子，每个概率为1/6
        vector<double>dp(6,1.0/6.0);
        for(int i=2;i<=n;i++){
            //每次的点数之和范围会有点变化，点数之和的值最大是i*6，
            //最小是i*1，i之前的结果值是不会出现的；
            //比如i=3个骰子时，最小就是3了，不可能是2和1，
            //所以点数之和的值的个数是6*i-(i-1)，化简：5*i+1
            vector<double>temp(5*i+1,0.0);
            //从i-1个骰子的点数之和的值数组入手，计算i个骰子的点数之和数组的值
            //先拿i-1个骰子的点数之和数组的第j个值，它所影响的是i个骰子时的temp[j+k]的值
            for(int j=0;j<dp.size();j++){
                for(int k=0;k<6;k++){
                    temp[j+k] += dp[j]/6.0;
                }
            }
            dp = temp;
        }
        return dp;
    }
};
```

## 66. 构建乘积数组

给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。

**示例：**

```
输入: [1,2,3,4,5]
输出: [120,60,40,30,24]
```

**思路**：分别计算B[i]左边的乘积和右边的乘积

<img src="/assets/blog_res/2022-03-21-%E5%89%91%E6%8C%87offer.assets/1624619180-vpyyqh-Picture1.png" alt="Picture1.png" style="zoom: 33%;" />

```c++
class Solution {
public:
    vector<int> constructArr(vector<int>& a) {
        int len = a.size();
        if(len==0) return{};
        vector<int>b(len,1);
        int temp=1;
        //计算b[i]左边元素的乘积
        for(int i=1;i<len;i++){
            b[i] = b[i-1]*a[i-1];
        }
        for(int i = len-2;i>=0;i--){
            temp*=a[i+1];
            b[i]*=temp;
        }
        return b;
    }
};
```

# 14. 数学

## 39. 数组中出现次数超过一半的数字

数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**示例：**

```
输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]
输出: 2
```

**思路**：用了哈希表统计次数，空间复杂度为O(N)，采用摩尔投票法降低复杂度。$x$表示众数，$vote$为投票数。如果当前的$vote=0$，此时的num就为众数，往右移动，当$num==x$时，vote就+1，当$num \ne x$时，vote就-1.

```
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int vote = 0,x=0;
        for(int num:nums){
            if(vote==0) x=num;
            if(num==x) vote+=1;
            else vote+=-1;
        }
        return x;
    }
};
```

## 43. 1~n整数中1出现的次数

输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。

例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。

**示例：**

```
输入：n = 12
输出：5
```

**思路**：当作开密码锁，首先考虑个位数，如果个位数的值也就是$cur==1$，那么就有$high*1$种情况，当cur等于其他值时类似。然后左移，依次考虑十位、百位等。

```c++
class Solution {
public:
    int countDigitOne(int n) {
        int high = n/10,cur = n%10,low = 0;
        long digit=1;
        int cnt = 0;
        while(high!=0||cur!=0){
            //当前位的值为0
            if(cur==0) cnt+=high*digit;
            else if(cur==1) cnt+=high*digit+low+1;
            else cnt+=(high+1)*digit;
            //修改高低位，进入下一次循环
            low+=digit*cur;
            cur = high%10;
            high /= 10;
            digit*=10;
        }
        return cnt;
    }
};
```

## 62. 圆圈中最后剩下的数字

0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。

 **示例：**

```
输入: n = 5, m = 3
输出: 3
```

**思路**：本题为约瑟夫环问题，想象成n个人，每次杀第m个人。有[A,B,C,D,E,F,G,H],以N=8,m=3为例，假设已知最终活下来的是G，N=8时，杀死c，G的索引是6.下一轮从D开始排序，G的索引变成了3.如果要将N=7变成N=8，就在末端插入C，然后向右移动m，将溢出的补充在最前面。可以发现,，此时G的索引变为$F(7,3)+3$.考虑到溢出，修改为$(F(7,3)+3)%8$。因此，$f(n,m)=(f(n-1,m)+m)\%n$

```c++
class Solution {
public:
    int lastRemaining(int n, int m) {
        int pos = 0;
        for(int i=2;i<=n;i++){
            pos = (pos+m)%i;
        }
        return pos;
    }
};
```

# 15. 位运算

## 15. 二进制中1的个数

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为 [汉明重量](http://en.wikipedia.org/wiki/Hamming_weight)).）。

**示例：**

```
输入：n = 11 (控制台输入 00000000000000000000000000001011)
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
```

**思路**：当n&1=1时，说明n的个位数为1，此时res+1；如果n&1=0，说明n的个位数为0.然后n右移一位，继续判断。或者考虑n&(n-1)，n&(n-1)可以消除n中的一个1，循环了几次，就说明有几个1.

```c++
//法一
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int res = 0;
        while(n){
            res+=n&1;
            n>>=1;
        }
        return res;        
    }
};
//法二
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int res = 0;
        while(n){
            res++;
            n = n&n-1;
        }
        return res;        
    }
};
```

## 56.1 数组中数字出现的次数

一个整型数组 `nums` 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

**示例 1：**

```
输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]
```

**思路**：两个相等的数字异或后为0，因此，对数组进行异或运算，可得到两个只出现一次的数字$x \oplus y$，由于$x \ne y$，则 x 和 y二进制至少有一位不同（即分别为 00 和 11 ），根据此位可以将 nums拆分为分别包含 x和 y的两个子数组。设辅助变量$m=1$，通过与运算从右向左循环判断，可获取$x \oplus y$首位1，记录到m。我们遍历数组，将每个数跟m进行与操作，结果为0的作为一组，结果不为0的作为一组。这样，就把x，y分到了不同的组别，再对这两个小组分别进行异或处理，我们就可以得到x和y。

```c++
class Solution {
public:
    vector<int> singleNumbers(vector<int>& nums) {
        int n=0,m=1,x=0,y=0;
        //遍历异或，得到两个不等的数字
        for(int num:nums){
            n^=num;
        }
        //循环左移，计算m,即x，y首位不相等的索引
        while((n&m)==0){
            m<<=1;
        }
        for(int num:nums){
            if((num&m)==0) x^=num;
            else y^=num;
        }
        return vector<int>{x,y};
    }
};
```

## 56.2 数组中数字出现的次数

在一个数组 `nums` 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。

**示例**：

```
输入：nums = [3,4,3,3]
输出：4
```

**方法一：有限状态自动机**

三个相同数字的二进制相加，再加上另一个数字的二进制，他们的和对3取余之后，得到的就是这个只出现了一次的数字。用两个二进制位two one表示状态00，01，10.

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int one = 0,two = 0;
        for(int num:nums){
            // if(two==0){
            //     one ^= num;
            // }
            // else{
            //     one = 0;
            // }
            one = one^num&~two;
            two = two^num&~one;
        }       
        return one;
    }
};
```

**方法二：遍历统计**

通过&与运算符可以获得num[i]最右边的一位，配合右移操作，可逐步获取num所有位的值。

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        //int的二进制位数
        vector<int>count(32,0);
        for(int num:nums){
            for(int i=0;i<32;i++){
                count[i]+=num&1;
                num>>=1;
            }
        }
        //利用二进制count还原res；
        int res=0,m=3;
        for(int i=0;i<32;i++){
            res<<=1;
            res|=count[31-i]%m;
        }
        return res;
    }
};
```

# 16. 其它

## 17. 打印从1到最大的n位数

输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。

**示例 1:**

```
输入: n = 1
输出: [1,2,3,4,5,6,7,8,9]
```

**思路**：最大的数位$10^n-1$，当n较大时，end会超出int32整型的取值范围，需要考虑**大数越界**问题。

任意变量类型，取值范围都是有限的，因此大数的表示应用**字符串String**类型。

```c++
class Solution {
public:
    vector<int> printNumbers(int n) {
        // 一次dfs添加i位的所有数字,比如i=3位是100-999,循环添加1-i
        for(int i = 1; i <= n; i++){
            dfs(0, i);
        }
        vector<int> ans;
        for(int i=0;i<res.size();i++){
            ans.push_back(stoi(res[i]));//stoi() 是string转int的函数 
        }
        return ans;
    }
private:
    vector<string> res;
    string s;
    char num[10] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};
    void dfs(int x,int len){//x表示从左往右第x位，len表示总共len位；
        if(x==len){//终止条件,x从0-len-1位已经循环完了，现在是第len位了 
            res.push_back(s);//把之前创建的s添加到字符串数组res中 比如x=0 i=1 时 第一个添加的s="1"
            return;
        }
        int start= (x==0)?1:0;//第一位特殊处理 去除0从1开始
        for(int i=start;i<10;i++){
            s.push_back(num[i]);//循环第x位从0-9，比如1
            dfs(x+1,len);//循环第x+1位0-9，接上上一位，s.push_back(num[i]) 比如10 11 12 13..
            s.pop_back(); //把最后一位清除
            //否则s在for(int i=start;i<10;i++循环中比如i=1时 s.push_back会变成1 12 123而不是1 2 3
        }
    }
};
```

## 19. 正则表达式匹配

请实现一个函数用来匹配包含``'. '``和'``*'``的正则表达式。模式中的字符'.'表示任意一个字符，而``'*'``表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串``"aaa"``与模式``"a.a"``和``"ab*ac*a"``匹配，但与``"aa.a"``和``"ab*a"``均不匹配。

**示例1：**

```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```

**思路**：动态规划，从后往前考虑。当p的最后一个字符不为*时，考虑两字符串最后一个是否相等。当p的最后一个字符为`*`时，考虑s[n-1]有该字符和无该字符。

```c++
class Solution {
public:
    bool isMatch(string s, string p) {
        int m=s.length(),n = p.length();
        vector<vector<bool>>dp(m+1,vector<bool>(n+1,false));
        for(int i=0;i<=m;i++){
            for(int j=0;j<=n;j++){
                //匹配串为空
                if(j==0){
                    dp[i][j] = i==0;
                }
                else{
                    //如果最后一位为非'*'
                    if(p[j-1]!='*'){
                        //如果i非空，就判断前一个是否相同。
                        if(i>0&&(s[i-1]==p[j-1]||p[j-1]=='.')){
                            dp[i][j] = dp[i-1][j-1];
                        }
                    }
                    //最后一位为'*'
                    else{
                        //s中不含p[j-1]，直接舍弃j的后两个
                        if(j>=2){
                            dp[i][j] =dp[i][j]|| dp[i][j-2];
                        }
                        if(i>=1&&j>=2&&(s[i-1]==p[j-2]||p[j-2]=='.')){
                            dp[i][j]=dp[i][j]||dp[i-1][j];
                        }
                    }
                }
            }
        }
        return dp[m][n];
    }
};
```

## ▲20. 表示数值的字符串

请实现一个函数用来判断字符串是否表示**数值**（包括整数和小数）。

示例：

```
输入：s = "0"
输出：true
```

## 44. 数字序列中某一位的数字

数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。

请写一个函数，求任意第n位对应的数字。

**示例：**

```
输入：n = 3
输出：3
```

**思路**：先确定n所在数字的位数，确定n指向哪个num，再确定n指向num中的哪一个数位。

```c++
class Solution {
public:
    int findNthDigit(int n) {
        int digit = 1;//位数
        long long start = 1;
        long long count = 9;
        while(n>count){
            n-=count;
            start *=10;
            digit++;
            count = 9*digit*start;
        }
        //2. 确定指向的数字
        int num = start + (n-1)/digit;
        //3. 确定指向的位数
        int a = (n-1)%digit;
        string s = to_string(num);
        return s[a]-'0';
    }
};
```

## 46. 把数字翻译成字符串

给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。

**示例 1:**

```
输入: 12258
输出: 5
解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"
```

**方法一：动态规划+转换字符串**，判断连续的两个数字之和是否在区间[10,25]之间

```c++
class Solution {
public:
    int translateNum(int num) {
        //初始化dp[0]、dp[1]为1
        int a=1,b=1;
        string s = to_string(num);
        for(int i=2;i<=s.size();i++){
            int temp = (s[i-2]-'0')*10+s[i-1]-'0';
            int c = temp>=10&&temp<=25 ? (a+b):b;
            a = b;
            b = c;
        }
        return b;
    }
};
```

**方法二：动态规划+数字求余**

```c++
class Solution {
public:
    int translateNum(int num) {
        //初始化dp[0]、dp[1]为1
        int a=1,b=1,x,y=num%10;
        while(num!=0){
            num/=10;
            x = num%10;//十位
            int temp = x*10+y;
            int c = temp>=10&&temp<=25 ? a+b:b;
            a = b;
            b = c;
            y=x;
        }
        return b;      
    }
};
```

## 61. 扑克牌中的顺子

从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。

**示例 1:**

```
输入: [1,2,3,4,5]
输出: True
```

**方法一：集合set+遍历**

```c++
class Solution {
public:
    bool isStraight(vector<int>& nums) {
        int maxVal = -1,minVal = 15;
        vector<bool>visited(14,false);
        for(int num:nums){
            if(num==0) continue;
            else{
                if(visited[num]) return false;
                visited[num] = true;
                maxVal = max(maxVal,num);
                minVal = min(minVal,num);
            }  
        }
        return maxVal-minVal<5;
    }
};
```

**方法二**：先**排序**，再判断相邻的两个数是否相等，如果相等，直接return false

```c++
class Solution {
public:
    bool isStraight(vector<int>& nums) {
    	//1. 排序
        sort(nums.begin(),nums.end());
        int joker = 0;
        //2. 计算大小王数量
        for(int i=0;i<4;i++){
            if(nums[i]==0) joker++;
            else if(nums[i]==nums[i+1]) return false;
        }
        return nums[4]-nums[joker]<5;
    }
};
```

## 64. 求1+2+...+n

求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

**示例 1：**

```
输入: n = 3
输出: 6
```

**思路：递归，用逻辑运算符来终止递归**

补充知识：

```
if(A && B)  // 若 A 为 false ，则 B 的判断不会执行（即短路），直接判定 A && B 为 false

if(A || B) // 若 A 为 true ，则 B 的判断不会执行（即短路），直接判定 A || B 为 true
```

```c++
class Solution {
public:
    int res = 0;
    int sumNums(int n) {
        bool x = n>1&&sumNums(n-1)>0;
        res+=n;
        return res;
    }
};
```

## 65. 不用加减乘除做加法

写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。

**示例:**

```
输入: a = 1, b = 1
输出: 2
```

**思路**：a，b当作二进制，异或运算相当于a，b无进位的求和，而与运算再左移一位相当于进位求和。

```
class Solution {
public:
    int add(int a, int b) {
        while(b!=0){
            //有进位的和
            int c = (unsigned int)(a&b)<<1;////C++中负数不支持左移位，因为结果是不定的
            a^=b;//无进位的和
            //如果还有进位，再循环，如果没有，则直接输出没有进位部分即可。
            b = c;
        }
        return a;
    }
};
```

## 67. 把字符串转换成整数

写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。

**示例：**

```
输入: "   -42"
输出: -42
解释: 第一个非空白字符为 '-', 它是一个负号。
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
```

**思路**：先删除前面的空格，判断符号，用sign保存。`res=res*10+x`

```c++
class Solution {
public:
    int strToInt(string str) {
        int n = str.size();
        if(n==0) return 0;
        int res = 0,border = INT_MAX/10;
        int i=0,sign = 1;
        //去除空格
        while(str[i]==' '){
            i++;
            if(i==(n-1)) return 0;
        }
        if(str[i]=='-') i+=1,sign=-1;
        else if(str[i]=='+') i+=1;//循环将从0开始
        for(int j=i;j<n;j++){
            //如果为其他字符，直接跳过
            if(str[j]<'0'||str[j]>'9') break;
            //判断边界
            if(res>border||res==border&&str[j]>'7') return sign==1?INT_MAX:INT_MIN;
            //此处应加括号改变运算优先级，否则会先加ascii，越界，报错
            res=res*10 + (str[j]-'0');
        }
        return sign*res;
    }
};
```

# 17. 树

## 07. 重建二叉树

输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。

假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

**示例：**

```
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
```

**思路：**首先通过前序遍历，找到根节点。前序遍历的第一个为根节点。然后在中序遍历中找到根节点，根结点左侧的为左子树，右侧为右子树。然后递归遍历。

```c++
class Solution {
public:
    TreeNode* traversal(vector<int>& preorder,int preBegin,int preEnd, vector<int>& inorder,int inBegin,int inEnd){
        //终止条件
        if(preBegin==preEnd) return NULL;
        //新建root结点
        TreeNode* root = new TreeNode(0);
        root->val = preorder[preBegin];
        if(preEnd-preBegin==1) return root;
        //找到分割点
        int delimeter=0;
        for(int i=inBegin;i<inEnd;i++){
            if(inorder[i]==root->val){
                delimeter=i;
                break;
            }
        }
        int leftinBegin = inBegin;
        int leftinEnd = delimeter;
        int rightinBegin = delimeter+1;
        int rightinEnd = inEnd;
        
        int leftpreBegin = preBegin+1;
        int leftpreEnd = preBegin+delimeter-inBegin+1;
        int rightpreBegin = preBegin+delimeter-inBegin+1;
        int rightpreEnd = preEnd;
        root->left = traversal(preorder,leftpreBegin,leftpreEnd,inorder,leftinBegin,leftinEnd);
        root->right = traversal(preorder,rightpreBegin,rightpreEnd,inorder,rightinBegin,rightinEnd);
        return root;
    }
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        return traversal(preorder,0,preorder.size(),inorder,0,inorder.size());
    }
};
```

## 26. 树的子结构

输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值。

**示例：**

```
输入：A = [1,2,3], B = [3,1]
输出：false
```

**思路**：新建一个traversal函数，用来判断B是否是A的子结构，这个函数不用递归，只需判断。在主函数中，递归A，判断A，A的左子树，A的右子树。

```c++
class Solution {
public:
    bool isSubStructure(TreeNode* A, TreeNode* B) {
        if(A==NULL||B==NULL) return false;
        return traversal(A,B)||isSubStructure(A->left,B)||isSubStructure(A->right,B);
    }
    //判断B是否是A的子结构
    bool traversal(TreeNode* A,TreeNode* B){
        if(B==NULL) return true;
        if(A==NULL||A->val!=B->val) return false;
        return traversal(A->left,B->left)&&traversal(A->right,B->right);
    }
};
```

## 32.1 从上到下打印二叉树

从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。

例如:
给定二叉树: `[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

返回：

```
[3,9,20,15,7]
```

**思路：层序遍历**

```c++
class Solution {
public:
    vector<int> levelOrder(TreeNode* root) {
        queue<TreeNode*>que;
        vector<int>res;
        if(root!=NULL) que.push(root);
        while(!que.empty()){
            int size = que.size();
            for(int i=0;i<size;i++){
                TreeNode* cur = que.front();
                que.pop();
                res.push_back(cur->val);
                if(cur->left) que.push(cur->left);
                if(cur->right) que.push(cur->right);
            }
        }
        return res;
    }
};
```

## 32.2 从上到下打印二叉树

从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。

**例如:**
给定二叉树: `[3,9,20,null,null,15,7]`,

```
   3
   / \
  9  20
    /  \
   15   7
```

返回其层次遍历结果：

```
[
  [3],
  [9,20],
  [15,7]
]
```

**思路：**二叉树的层序遍历

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
```

## 32.3 从上到下打印二叉树

请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。

例如:
给定二叉树: `[3,9,20,null,null,15,7]`,

```
   3
   / \
  9  20
    /  \
   15   7
```

返回其层次遍历结果：

```
[
  [3],
  [20,9],
  [15,7]
]
```

**思路：**

**方法一：层序遍历+双端队列**

用双端队列代替原队列，奇数时从尾部弹出节点，从头部插入节点；偶数时从头部弹出，尾部插入。

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        if(root==NULL) return {};
        deque<TreeNode*>dq;
        dq.push_back(root);
        vector<vector<int>>res;
        int level = 0;
        while(!dq.empty()){
            int size = dq.size();
            res.push_back(vector<int>(size));
            //偶数，尾入头出
            if(level%2==0){
                for(int i=0;i<size;i++){
                    TreeNode* cur = dq.front();
                    dq.pop_front();
                    res[level][i] = cur->val;
                    if(cur->left) dq.push_back(cur->left);
                    if(cur->right) dq.push_back(cur->right);
                }
            }
            //奇数
            else{
                for(int i=0;i<size;i++){
                    TreeNode* cur = dq.back();
                    dq.pop_back();
                    res[level][i] = cur->val;
                    if(cur->right) dq.push_front(cur->right);
                    if(cur->left) dq.push_front(cur->left);
                }
            }
            level++;    
        }
        return res;
    }
};
```

**方法二：层序遍历+双栈**

用两个栈分别保存奇数层的节点和偶数层的节点。

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        if(root==NULL) return {};
        stack<TreeNode*>s1;//保存偶数层
        stack<TreeNode*>s2;//保存奇数层
        s1.push(root);
        vector<vector<int>>res;
        int count = 0;
        while(!s1.empty()||!s2.empty()){
            vector<int>temp;
            //偶数，尾入头出
            if(count%2==0){
                int size = s1.size();
                for(int i=0;i<size;i++){
                    TreeNode* cur = s1.top();
                    s1.pop();
                    temp.push_back(cur->val);
                    //偶数层的数，让子节点进入奇数层，左边先进，先进后出，栈弹出实现从右向左
                    if(cur->left) s2.push(cur->left);
                    if(cur->right) s2.push(cur->right);
                }
            }
            //奇数
            else{
                int size = s2.size();
                for(int i=0;i<size;i++){
                    TreeNode* cur = s2.top();s2.pop();
                    temp.push_back(cur->val);
                    //奇数层的数，让子节点进入偶数层，右边先进入
                    if(cur->right) s1.push(cur->right);
                    if(cur->left) s1.push(cur->left);
                }
            }
            count++;
            res.push_back(temp);
        }
        return res;
    }
};
```

**方法三：层序遍历+倒序**

在往数组里存数据时，判断奇偶。偶数的话，就从左到右存，奇数的话就从右到左存。

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        if(root==NULL) return {};
        queue<TreeNode*>que;
        que.push(root);
        vector<vector<int>>res;
        int level=0;
        while(!que.empty()){
            int size = que.size();
            res.push_back(vector<int>(size));
            for(int i=0;i<size;i++){
                TreeNode* cur = que.front();
                que.pop();
                if(level%2==0) res[level][i] = cur->val;
                else res[level][size-i-1] = cur->val;
                if(cur->left) que.push(cur->left);
                if(cur->right) que.push(cur->right);                
            }
            level++;
        }
        return res;
    }
};
```

## 33. 二叉搜索树的后序遍历序列

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 `true`，否则返回 `false`。假设输入的数组的任意两个数字都互不相同。

参考以下这颗二叉搜索树：

```
     5
    / \
   2   6
  / \
 1   3
```

**示例 1：**

```
输入: [1,6,3,2,5]
输出: false
```

**示例 2：**

```
输入: [1,3,2,6,5]
输出: true
```

**方法一：递归**

后序遍历，最右边为根节点。左子树的值均小于根节点，右子树均大于根节点。

```c++
class Solution {
public:
    bool verifyPostorder(vector<int>& postorder) {
        //if(postorder.size()==0) return true;
        return traversal(postorder,0,postorder.size()-1);
    }
    bool traversal(vector<int>& postorder,int start,int end){
        if(start>=end) return true;
        //找到第一个大于根节点的值的位置
        int pos = start;
        while(postorder[pos]<postorder[end]) pos++;
        //右子树的值应都大于根节点，遍历右子树，如果pos!=end，说明个数不对，为false
        int m = pos;//记录pos位置，用于递归
        while(postorder[pos]>postorder[end]) pos++;
        return end==pos&&traversal(postorder,start,m-1)&&traversal(postorder,m,end-1);
    }
};
```

**方法二：[栈](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/di-gui-he-zhan-liang-chong-fang-shi-jie-jue-zui-ha/)**

```c++
class Solution {
public:
    bool verifyPostorder(vector<int>& postorder) {
        stack<int>st;
        int parent = INT_MAX;
        //注意for循环是倒叙遍历的
        for(int i=postorder.size()-1;i>=0;i--){
            int cur = postorder[i];
            //当如果前节点小于栈顶元素，说明栈顶元素和当前值构成了倒叙，
            //说明当前节点是前面某个节点的左子节点，我们要找到他的父节点
            while(!st.empty()&&st.top()>cur){
                parent = st.top();
                st.pop();
            }
            /只要遇到了某一个左子节点，才会执行上面的代码，才会更
            //新parent的值，否则parent就是一个非常大的值，也就
            //是说如果一直没有遇到左子节点，那么右子节点可以非常大
            if(cur>parent) return false;
            //如果递增，就入栈
            st.push(cur);
        }
        return true;
    }
};
```

## 34.2 二叉树中和为某一值的路径

给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。

叶子节点 是指没有子节点的节点。

示例：

![img](/assets/blog_res/2022-03-21-%E5%89%91%E6%8C%87offer.assets/pathsumii1.jpg)

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]
```

**思路：**先序遍历的回溯算法

```c++
class Solution {
public:
    vector<vector<int>> pathSum(TreeNode* root, int target) {
        backTracking(root,target,path,0);
        return res;
    }
private:
    vector<vector<int>>res;
    vector<int>path;
    void backTracking(TreeNode* root,int target,vector<int>&path,int sum){
        //返回条件
        if(root==nullptr) return;
        sum+=root->val;
        path.push_back(root->val);
        if(sum==target&&root->left==nullptr&&root->right==nullptr) res.push_back(path);
        backTracking(root->left,target,path,sum);
        backTracking(root->right,target,path,sum);
        sum-=root->val;
        path.pop_back();
    }
};
```

## 37. 序列化二叉树

请实现两个函数，分别用来序列化和反序列化二叉树。

你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

提示：输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。

示例：

![img](/assets/blog_res/2022-03-21-%E5%89%91%E6%8C%87offer.assets/serdeser.jpg)

```
输入：root = [1,2,3,null,null,4,5]
输出：[1,2,3,null,null,4,5]
```

**思路：**

序列化：按照层序遍历的方式，将节点存入string

反序列化：先把节点存入vector数组，然后遍历vector数组，将节点之间的关系构建出来。

```c++
class Codec {
public:
    // 序列化
    string serialize(TreeNode* root) {
        //层序遍历
        string res = "";
        if(root==NULL) return res;
        queue<TreeNode*>que;
        que.push(root);
        while(!que.empty()){
            int size = que.size();
            for(int i=0;i<size;i++){
                TreeNode* cur = que.front();
                que.pop();
                if(cur!=NULL){
                    res.append(to_string(cur->val));
                    res.push_back(',');
                    que.push(cur->left);
                    que.push(cur->right);
                }
                else{
                    res.append("nullptr,");
                }
            }
        }
        //去掉最后的逗号
        res.pop_back();
        return res;
    }
    // 反序列化
    TreeNode* deserialize(string data) {
        //利用队列 按层构建二叉树
        //特例
        if(data.size()==0) return nullptr;
        vector<TreeNode*>nodes;
        //把data存入节点
        int j=0;
        while(j<data.size()){
            string temp = "";
            //遇到逗号隔开
            while(j<data.size()&&data[j]!=','){
                temp+=data[j];
                j++;
            }
            if(temp=="nullptr"){
                nodes.push_back(NULL);
            }
            else{
                int m = stoi(temp);
                TreeNode* newnode = new TreeNode(m);
                nodes.push_back(newnode);
            }
            j++;
        }
        //构建节点关系
        int pos = 1;
        for(int i=0;i<nodes.size();i++){
            //空节点没有左右孩子
            if(nodes[i]==nullptr) continue;
            nodes[i]->left = nodes[pos++];
            nodes[i]->right = nodes[pos++];
        }
        return nodes[0];
    }
};
```

## 54. 二叉搜索树的第k大节点

给定一棵二叉搜索树，请找出其中第 `k` 大的节点的值。

**示例：**

```
输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 4
```

**思路：**中序遍历的倒序

```c++
class Solution {
public:
    int res;
    void traversal(TreeNode* root,int &k){
        if(root==NULL) return;
        traversal(root->right,k);
        k--;
        if(k==0) res = root->val;
        traversal(root->left,k);     
    }
    int kthLargest(TreeNode* root, int k) {
        traversal(root,k);
        return res;
    }
};
```

## 55.2 平衡二叉树

输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。

**示例 1:**

给定二叉树 `[3,9,20,null,null,15,7]`

```
    3
   / \
  9  20
    /  \
   15   7
```

**思路**：递归，后序遍历

```c++
class Solution {
public:
    //求高度，后序遍历
    int getHeight(TreeNode* root){
        if(root==NULL) return 0;
        int left = getHeight(root->left);
        if(left==-1) return -1;
        int right = getHeight(root->right);
        if(right==-1) return -1;
        return abs(left-right)>1?-1:1+max(left,right);
    }
    bool isBalanced(TreeNode* root) {
        return getHeight(root)==-1?false:true;
    }
};
```

## 68.1 二叉搜索树的最近公共祖先

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]

![img](/assets/blog_res/2022-03-21-%E5%89%91%E6%8C%87offer.assets/binarysearchtree_improved.png)

**示例：**

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。
```

**方法一**：递归+先序遍历

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root==NULL) return root;
        if(root->val>p->val&&root->val>q->val) 
        {
            return lowestCommonAncestor(root->left,p,q);
        }
        else if(root->val<p->val&&root->val<q->val){
            return lowestCommonAncestor(root->right,p,q);
        }
        else return root;
    }
};
```

**方法二**：迭代

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        while(root!=NULL){
            if(root->val>p->val&&root->val>q->val){
                root = root->left;
            }
            else if(root->val<p->val&&root->val<q->val){
                root = root->right;
            }
            else return root;
        }
        return root;
    }
};
```

## 68.2 二叉树的最近公共祖先

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]

![img](/assets/blog_res/2022-03-21-%E5%89%91%E6%8C%87offer.assets/binarytree.png)

**示例：**

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
```

**思路**：后序遍历，分别遍历左右子树，看p、q是否在子树里

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        //后序遍历，从下往上
        if(root==p||root==q||root==NULL) return root;
        TreeNode* left = lowestCommonAncestor(root->left,p,q);
        TreeNode* right = lowestCommonAncestor(root->right,p,q);
        if(left!=NULL&&right!=NULL) return root;
        if(left==NULL&&right!=NULL) return right;
        else if(left!=NULL&&right==NULL) return left;
        else return NULL;
    }
};
```

