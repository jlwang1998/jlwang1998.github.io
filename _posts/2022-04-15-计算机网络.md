---
title: 计算机网络
date: 2022-04-15 20:00:00 +0800
categories: [八股，计算机网络]
tags: [计算机网络]
pin: true
author: 王家乐

toc: true
comments: true
typora-root-url: ../../jlwang1998.github.io
math: false
mermaid: true
---

# 1. 计算机网络

## 1.1 TCP/IP五层协议或OSI七层参考模型

TCP/IP五层协议：

- 应用层：应用层协议（HTTP、SMTP、FTP）分布在多个端系统上，而一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息分组，位于应用层的信息分组称为报文；提供用户接口，特指能够发起网络流量的程序

- 运输层：在应用程序端点之间传送应用层报文。在因特网中，有两种运输协议，即TCP和UDP，利用其中的任一个都能运输应用层报文。运输层的分组称为报文段；（数据成功传给对方电脑后，不知道传给哪个应用程序）提供的是进程间的通用数据传输服务。只有有了IP和端口，我们才能进行准确的通信。

- 网络层：将运输层的报文段和目的地址封装成数据报，用于下一层的传输，网络层协议有IP，网络层的分组称为数据报；（负责选择最佳路径 规划IP地址）

  - IP协议：
    - IP地址由 32 位的二进制数组成，一般把它分成4段的十进制表示，地址范围为0.0.0.0~255.255.255.255。
    - 每一台想要联网的计算机都会有一个IP地址。这个IP地址被分为两部分，前面一部分代表**网络部分**，后面一部分代表**主机部分**。并且网络部分和主机部分所占用的二进制位数是不固定的。如果两台计算机的网络部分完全一致，那么说明这两台计算机处于同一个子网中。如192.168.43.1和192.168.43.2，网络部分为24位，主机部分为8位。
    - 如何判断网络部分和主机部分所占位数？如何判断IP地址是否在一个子网？
      - 利用子网掩码，子网掩码和IP地址一样也是 32 位二进制数，不过它的网络部分规定全部为 1，主机部分规定全部为 0.这样就知道了所占位数。将IP地址与子网掩码进行**与运算**，如果结果相同，则在一个子网。
  - ARP协议：如何知道其他计算机的MAC地址？
    - 通过广播的形式给同一个子网中的每台电脑发送一个数据包，数据包包含接收方的IP地址，对方收到这个数据包之后，会取出IP地址与自身的对比，如果相同，则把自己的MAC地址回复给对方，否则就丢弃这个数据包。
    - 发送数据通过广播，询问对方MAC地址也是广播，如何区分呢？
      - 在询问MAC地址的数据包中，在对方的MAC地址这一栏中，填的是一个特殊的MAC地址，其他计算机看到这个特殊的MAC地址之后，就能知道广播想干嘛了。
  - DNS服务器
    - 如何知道对方的IP地址？
      - 输入网址域名www.baidu.com，DNS服务器解析域名，返回这个域名对应的IP地址。

- 链路层：不同的网络类型，发送数据的机制不同，数据链路层就是将数据包封装成能够在不同的网络传输的帧。能够进行差错检验，但不纠错，监测处错误丢掉该帧。制定一套规则来进行0，1的传送。例如多少个电信号为一组啊，每一组信号应该如何标识才能让计算机读懂啊等等。

  - 以太网协议：一组电信号构成一个数据包，我们把这个数据包称之为**帧**。每一个桢由标头(Head)和数据(Data)两部分组成。Head存储发送者，接收者等信息。而数据部分则是这个数据包具体的，想给接收者的内容。Head长度固定为18个字节。

  - MAC地址：连入网络的每一个计算机都会有网卡接口，每一个网卡都会有一个唯一的地址，这个地址就叫做 MAC 地址。计算机之间的数据传送，就是通过 MAC 地址来唯一寻找、传送的。MAC地址 由 48 个二进制位所构成，在网卡生产时就被唯一标识。

  - 广播与ARP协议：

    -  在同一个**子网**中，计算机 A 要向计算机 B 发送一个数据包，这个数据包会包含接收者的 MAC 地址。当发送时，计算机 A 是通过**广播**的方式发送的，这时同一个子网中的计算机 C, D 也会收到这个数据包的，然后收到这个数据包的计算机，会把数据包的 MAC 地址取出来，与自身的 MAC 地址对比，如果两者相同，则接受这个数据包，否则就丢弃这个数据包。这种发送方式我们称之为广播。

    - ARP 协议，通过它我们可以知道子网中其他计算机的 MAC 地址。

- 物理层：将帧中的一个个比特从一个节点移动到下一个节点。负责把两台计算机连起来，然后在计算机之间通过高低电频来传送0,1这样的电信号。

## 1.2 通信双方如何保证消息不丢失？

数据在传输的时候是分割成一小块一小块传输的，我们把这一小块的数据称之为一个分组。我们在传输这块分组的时候，主要面临两个问题：

- 分组在信道传输中，受到干扰，导致这个分组到达目的地之后出现了差错，例如分组里面的二进制位1变成了0，0变成了1；
  - 给每个分组添加序号，分组中放入校验码，当接收方收到分组时，可根据校验码判断是否出现差错。如果没有差错，接收方就给发送方发送一个ACK分组，告诉对方，数据正确无误。如果出现差错的话，就给对方发送一个NAK分组，告诉对方，分组数据出现了差错。当计算机A收到接受方的反馈之后，如果收到的是ACK分组，那么就继续发送下一个分组数据。如果收到的是NAK分组，那么就重新传输这个分组。接收方根据序号判断传输的是新分组还是重传的。（GBN）
- 分组还没传输到目的地，就丢失了，我们也把这种情况称之为丢包。
  - 设置一个超时定时器，如果发送方没有收到接收方的反馈，就超时重传。

发送方一次只发送一个分组，效率低。使用流水线协议。

- 回退N步协议（GBN），也称为滑动窗口协议：在回退N步法中允许发送多个分组而不需要等待确认，但它也受限于在流水线中未确认的分组数不能超过某个最大允许数N。

<img src="https://img-blog.csdnimg.cn/20191220202855367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTA3Nzk3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 50%;" />

- base为最早的未确认分组的序号，nextseqnum为最小的未使用序号。可以将序号分成4段。在[0, base-1]段内的序号对应已发送并且已经确认的分组序号，[base,nextseqnum-1]段内对应已经发送但未确认的分组序号，[nextseqnum, base+N-1]段内表示即将要被发送的分组序号，大于base+N的序号目前还不能使用，直到当前流水线中未被确认的分组得到确认，窗口整体向右移动之后，才能够被使用。

- 发送方需要响应以下两个事件：
  - 收到一个ACK：在GBN协议中，对序号为n的分组的确认采取累计确认的方式。也就是说，当A收到序号为n的分组时，表明分组n以及n之前的分组已经被接收方正确接受了。
  - 超时事件：当很久没有收到ACK时，发送方就认为它发送的分组已经丢失了，这时发送方会重传所有已发送但还未被确认的分组。并不是为每个分组设置一个定时器，而是在序号[base,nextseqnum-1]中，设置一个定时器，当base发送的那一刻，就开始计时，当收到一个ACK时，则刷新重新开始计时。
- 接收方需要响应：
  - 如果一个序号为n的分组被正确收到，并且按序(所谓按序就是指n-1的分组也已经收到了)，则B为分组n发送一个ACK，否则，丢弃该分组，并且为最近按序接收的分组重新发送ACK。

**选择重传协议：**

回退N步协议的缺点也是很明显的，单个分组的差错能够引起GBN重传大量的分组，而且许多分组根本就没有必要重传。在选择重传中，接收方收到失序的分组时，会把它缓存起来，直到拼凑到分组按序，才把分组传输给上一层。而发送方会为每个分组设置一个定时器，这样，只需要重传那些没有被接收方正确接收的分组就可以了。

<img src="https://img-blog.csdnimg.cn/20191220203147713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTA3Nzk3,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" />

## 1.3 集线器、交换机与路由器的区别

集线器：具备多个网口，专门实现多台计算机的互联作用，集线器是通过网线直接传送数据的，我们说他工作在**物理层**。存在问题：集线器无法分辨具体信息是发送给谁的，只能广播。小A说话时其他人不能发言，否则信息间会产生**碰撞**，引发错误，我们叫做各设备处于同一**冲突域内**。

交换机：把用户的网口命名，根据网口名称自动寻址传输数据，解决了冲突的问题，实现了任意两台电脑间的互联，大大地提升了网络间的传输速度。由于交换机是根据网口地址传送信息，比网线直接传送多了一个步骤，我们也说交换机工作在**数据链路层**。

路由器：操作系统不同时，信息的传送形式不匹配。把信息经协议加工成统一形式，再经由一个特殊的设备传送出去。这个设备就是路由器。路由器通过IP地址寻址，我们说它工作在计算机的**网络层**。

## 1.4 TCP拥塞控制？

区分拥塞控制和流量控制：拥塞控制与网络的拥堵情况相关联，而流量控制与接收方的缓存状态相关联。

### 1.4.1 为什么要进行拥塞控制？

两台主机在传输数据包的时候，如果发送方迟迟没有收到接收方反馈的 ACK，那么发送方就会认为它发送的数据包丢失了，进而会重新传输这个丢失的数据包。实际情况有可能此时有太多主机正在使用信道资源，导致**网络拥塞**了，而 A 发送的数据包被堵在了半路，迟迟没有到达 B。这个时候 A 就会误认为是发生了丢包情况，进而重新传输这个数据包。这样会浪费信道资源，使网络更加拥塞，因此需要进行拥塞控制。

### 1.4.2 如何知道网络的拥塞情况？

拥塞窗口：发送方一次性连续发送数据包的个数N。

两种策略：

1. 先发送一个数据包试探下，如果该数据包没有发生超时事件(也就是没有丢包)。那么下次发送时就发送2个，如果还是没有发生超时事件，下次就发送3个，以此类推，即N = 1, 2, 3, 4, 5…..
2. 刚开始发送1个，如果没有发生超时时间，就发送2个，如果还是没有发送超时事件就发送4个，接着8个…，用翻倍的速度类推,即 N = 1, 2, 4, 8, 16…

方法一增长过慢，方法二增长过快，把二者结合起来。设置一个阈值，当增长到阈值时，我们就不在以指数增长了，而是一个一个线性增长。把指数增长阶段称之为**慢启动**，线性增长阶段称之为**拥塞避免**。

### 1.4.3 到了瓶颈值怎么办？

回到最初的状态，也就是说从1，2，4，8…..开始，但是把阈值调整为瓶颈值的一半。

### 1.4.4 超时事件一定是网络拥塞吗？

不一定，有可能是某个数据包出现了丢失或者损害，导致这个数据包超时事件发送。

为了防止这种情况，通过**冗余 ACK**来处理。数据包是有序号的，如果A给B发送M1, M2, M3, M4, M5…N个数据包，如果B收到了M1, M2, M4….却始终没有收到M3，这个时候就会重复确认M2，意在告诉A,M3还没收到，可能是丢失。当A连续收到了三个确认M2的ACK，且M3超时事件还没发生。A就知道M3可能丢失了，这个时候A就不必等待M3设置的计时器到期了，而是快速重传M3。并且把阈值设置为MAX的一半，但是这个时候并非把控制窗口N设置为1，而是让N = 阈值，N再一个一个增长。

这种情况称为**快速恢复**，这种具有快速恢复的TCP版本称之为**TCP Reno**。

还有另外一种TCP版本，无论是收到三个相同的ACK还是发生超时事件，都把拥塞窗口的大小设为1，从最初状态开始，这种版本的TCP我们称之为**TCP Tahoe**。

## 1.5 TCP流量控制

流量控制：对发送方速率的控制。

### 1.5.1 为什么要进行流量控制？

双方在通信的时候，发送方的速率与接收方的速率是不一定相等，如果发送方的发送速率太快，会导致接收方处理不过来，这时候接收方只能把处理不过来的数据存在**缓存区**里（失序的数据包也会被存放在缓存区里）。

如果缓存区满了发送方还在疯狂着发送数据，接收方只能把收到的数据包丢掉，大量的丢包会极大着浪费网络资源，因此，我们需要控制发送方的发送速率，让接收方与发送方处于一种**动态平衡**才好。

### 1.5.2 如何进行流量控制？

接收方每次收到数据包，可以在发送确定报文的时候，同时告诉发送方自己的缓存区还剩余多少是空闲的，我们也把缓存区的剩余大小称之为**接收窗口**大小，用变量 **win**来表示接收窗口的大小。

发送方收到之后，便会调整自己的发送速率，也就是调整自己**发送窗口**的大小，当发送方收到接收窗口的大小为0时，发送方就会停止发送数据，防止出现大量丢包情况的发生。

<img src="https://img-blog.csdnimg.cn/20191215181603583.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTA3Nzk3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

### 1.5.3 发送方何时继续发送数据？

当发送方收到接受窗口 win = 0 时，这时发送方停止发送报文，并且同时开启一个**定时器**，每隔一段时间就发个**测试报文**去询问接收方，打听是否可以继续发送数据了，如果可以，接收方就告诉他此时接受窗口的大小；如果接受窗口大小还是为0，则发送方再次刷新启动定时器。

### 1.5.4 接收窗口大小固定吗？

早期固定，随着网络发展，固定大小的窗口不灵活，成为TCP性能瓶颈之一。现在的不固定，接收窗口的大小是根据某种算法动态调整的。

### 1.5.5 接收窗口越大越好吗？

接收窗口太小：浪费链路利用率，增加丢包率。当接收窗口达到某个值的时候，再增大的话也不怎么会减少丢包率的了，而且还会更加消耗内存。所以接收窗口的大小必须根据网络环境以及发送方的拥塞窗口来动态调整。

### 1.5.6 发送窗口和接收窗口相等吗？

接收方在发送确认报文的时候，会告诉发送发自己的接收窗口大小，而发送方的发送窗口会据此来设置自己的发送窗口，但这并不意味着他们就会相等。首先接收方把确认报文发出去的那一刻，就已经在一边处理堆在自己缓存区的数据了，所以一般情况下接收窗口 >= 发送窗口。

## 1.6 TCP三次握手和四次挥手

### 1.6.1 三次握手

**为什么需要三次握手？**

1、第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 **ISN(c)**。此时客户端处于 **SYN_Send** 状态。

2、第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 **SYN_REVD** 的状态。

3、第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 **establised** 状态。

4、服务器收到 ACK 报文之后，也处于 **establised 状态**，此时，双方以建立起了链接。

**三次握手的作用？**

1、确认双方的接受能力、发送能力是否正常。

2、指定自己的初始化序列号，为后面的可靠传送做准备。

**为什么只有三次握手才能确认双方的接受与发送能力是否正常，而两次却不可以？**

第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。

第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。

第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。因此，需要三次握手才能确认双方的接收与发送能力是否正常。

**（ISN）是固定的吗？**

三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。

**什么是半连接队列？**

服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为**半连接队列**。当然还有一个**全连接队列**，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

**三次握手过程中可以携带数据吗？**

第三次握手时可以。

假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。

对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了。

### 1.6.2 四次挥手

刚开始双方都处于 establised 状态，假如是客户端先发起关闭请求，则：

1、第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于**FIN_WAIT1**状态。

2、第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 **CLOSE_WAIT**状态。

3、第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 **LAST_ACK** 的状态。

4、第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 **TIME_WAIT** 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态。

5、服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。

**为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭？**

要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。

> LISTEN – 侦听来自远方TCP端口的连接请求；
>
> SYN-SENT -在发送连接请求后等待匹配的连接请求；
>
> SYN-RECEIVED – 在收到和发送一个连接请求后等待对连接请求的确认；
>
> ESTABLISHED- 代表一个打开的连接，数据可以传送给用户；
>
> FIN-WAIT-1 – 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；
>
> FIN-WAIT-2 – 从远程TCP等待连接中断请求；
>
> CLOSE-WAIT – 等待从本地用户发来的连接中断请求；
>
> CLOSING -等待远程TCP对连接中断的确认；
>
> LAST-ACK – 等待原来发向远程TCP的连接中断请求的确认；
>
> TIME-WAIT -等待足够的时间以确保远程TCP接收到连接中断请求的确认；
>
> CLOSED – 没有任何连接状态；

## 1.7 什么是HTTP？

### 1.7.1 HTTP/0.9

HTTP 是基于 TCP/IP 协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。

0.9版本只有get命令。协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。服务器发送完毕，就关闭TCP连接。

### 1.7.2 HTTP/1.0

任何格式的内容都可以发送，除了GET命令，还引入了POST命令和HEAD命令，丰富了浏览器与服务器的互动手段。HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。

回应的格式是”头信息 + 一个空行（\r\n） + 数据”。其中，第一行是”协议版本 + 状态码（status code） + 状态描述”。

头信息必须是 ASCII 码，后面的数据可以是任何格式。服务器回应的时候，必须告诉客户端，数据是什么格式，这就是Content-Type字段的作用。

**缺点**：每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。使用keep-alive来保持TCP链接。

### 1.7.3 HTTP/1.1

**持久连接**：TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。

**管道机制**：在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。

**如何区分数据包属于哪个回应？**

- Content-length字段，声明本次回应的数据长度。
- 使用Content-Length字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer）。分块传输编码：每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。

**缺点**：同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为”队头堵塞”（Head-of-line blocking）。

### 1.7.4 HTTP/2

HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。二进制的好处：可以定义额外的帧如果使用文本实现这种功能，解析数据将会变得非常麻烦。

**多工**：HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。这样双向的、实时的通信，就叫做多工（Multiplexing）。

**数据流**

1. 因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。
2. HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。
3. 数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。
4. 客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。

**头信息压缩**：HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，浪费带宽。通过头信息压缩机制，一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。

**服务器推送**：允许服务器未经请求，主动向客户端发送资源。服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。

## 1.8 什么是HTTPS？

http协议没有对数据加密，都是明文传输的。

**如何对数据加密？**

- **对称加密**：在每次发送真实数据之前，服务器先生成一把密钥，然后先把密钥传输给客户端。之后服务器给客户端发送真实数据的时候，会用这把密钥对数据进行加密，客户端收到加密数据之后，用刚才收到的密钥进行解密。
  - **对称加密的问题**：密钥是通过明文传输的，如果密钥被中间人给捕获了，那么在之后服务器和客户端的加密传输过程中，中间人也可以用他捕获的密钥进行解密。这样的话，加密的数据在中间人看来和明文没啥两样。
- **非对称加密**：让客户端和服务器都拥有两把钥匙，一把钥匙是公开的(全世界知道都没关系)，我们称之为公钥；另一把钥匙则是保密的(只有自己本人才知道)，我们称之为私钥。这样，**用公钥加密的数据，只有对应的私钥才能解密；用私钥加密的数据，只有对应的公钥才能解密**。
  - **非对称加密的问题**：加密速度慢，比对称加密慢了上百倍。
- **对称和非对称加密结合**：用非对称加密的方式来传输对称加密过程中的密钥，之后我们就可以采取对称加密的方式来传输数据。服务器用明文的方式给客户端发送自己的公钥，客户端收到公钥之后，会生成一把密钥(对称加密用的)，然后用服务器的公钥对这把密钥进行加密，之后再把密钥传输给服务器，服务器收到之后进行解密，最后服务器就可以安全着得到这把密钥了，而客户端也有同样一把密钥，他们就可以进行对称加密了。
  - 非对称加密也不一定安全，中间人截取服务器发送给客户端的明文公钥，中间人用自己的公钥冒充服务器的传输给客户端。客户端用中间人的公钥生成自己的密钥，被加密的密钥传输给服务器。中间人截取密钥，中间人用自己的私钥对密钥解密，解密后中间人就可以获得这把密钥了。中间人再对这把密钥用刚才服务器的公钥进行加密，再发给服务器。
  - 非对称加密不安全是因为客户端不知道公钥是不是属于服务器的。
- **数字证书**：证明公钥是属于服务器的，需要找到一个拥有公信力、大家都认可的**认证中心(CA)**。服务器在给客户端传输公钥的过程中，会把公钥以及服务器的个人信息通过Hash算法生成**信息摘要**。为了防止信息摘要被人调换，服务器还会用CA提供的私钥对信息摘要进行加密来形成**数字签名**。并且，最后还会把原来没Hash算法之前的个人信息以及公钥 和 数字签名合并在一起，形成**数字证书**。当客户端拿到这份数字证书之后，就会用CA提供的公钥来对数字证书里面的数字签名进行解密来得到信息摘要，然后对数字证书里服务器的公钥以及个人信息进行Hash得到**另外一份信息摘要**。最后把**两份信息摘要进行对比**，如果一样，则证明这个人是服务器，否则就不是。
  - CA的公钥是怎么拿给客户端的？服务器怎么有CA的私钥？
  - 服务器一开始就向认证中心申请了这些证书，而客户端是，也会内置这些证书。当客户端收到服务器传输过来的数据数字证书时，就会在内置的证书列表里，查看是否有解开该数字证书的公钥。

## 1.9 SSL/TLS协议

HTTPS是其实就是在HTTP协议上套上一层SSL加密。

**作用**：

- 窃听风险：第三方可以获知通信内容
- 篡改风险：第三方可以修改通信内容
- 冒充风险：第三方可以冒充他人身份参与通信

SSL/TLS协议可以实现：

- 所有信息都是**加密传播**，第三方无法窃听
-  具有**校验机制**，一旦被篡改，通信双方会立刻发现
- 配备**身份证书**，防止身份被冒充

**基本运行过程：**

采用公钥加密法，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。前两步称为**握手阶段**。

（1） 客户端向服务器端索要并验证公钥。

（2） 双方协商生成”对话密钥”。

（3） 双方采用”对话密钥”进行加密通信。

**握手阶段的过程：**

- 客户端发出请求(ClientHello)：客户端向服务器发出加密通信的请求，客户端提供信息有：支持的协议版本，比如TLS 1.0版；一个客户端生成的随机数，稍后用于生成”对话密钥”；支持的加密方法，比如RSA公钥加密；支持的压缩方法。

- 服务器回应(SeverHello)：确认使用的加密通信协议版本；一个服务器生成的随机数，稍后用于生成”对话密钥”；确认使用的加密方法，比如RSA公钥加密；服务器证书。

- 客户端回应：客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。

  - 一个随机数。该随机数用服务器公钥加密，防止被窃听。

  -  编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。

  - 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。

    - 三个随机数，生成**对话密钥**。**为什么是三个随机数？**

    - SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，因此必须引入新的随机因素。

- 服务器的最后回应：服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息。

  - 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。

  - 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。

**如何保证公钥不被篡改？**

将公钥放在数字证书中，只要证书是可信的，公钥就是可信的。

公钥计算量太大，如何减少消耗的时间？

每一次对话（session），客户端和服务器端都生成一个”对话密钥”（session key），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。

## 1.10 DNS

DNS：Domain Name System，根据域名查出IP地址。

查询过程：

1. 查询参数和统计；
2. 查询内容；
3. DNS服务器的答复；
4. 显示stackexchange.com的NS记录（Name Server的缩写），即哪些服务器负责管理stackexchange.com的DNS记录；
5. 四个域名服务器的IP地址；
6. DNS服务器的一些传输信息。

DNS服务器：本机一定知道DNS服务器的IP地址，否则上不了网。DNS服务器的IP地址，有可能是动态的，每次上网时由网关分配，这叫做**DHCP机制**；也有可能是事先指定的固定地址。

**域名的层级：**

DNS通过**分级查询**每个域名的IP地址，www.example.com真正的域名是www.example.com.root，简写为www.example.com.。因为，根域名.root对于所有域名都是一样的，所以平时是省略的。**根域名**的下一级是顶级域名，如.com、.net；**次级域名**，比如www.example.com里面的.example，这一级域名是用户可以注册的；**主机名**(host)，比如www.example.com里面的www，又称为”三级域名”，这是用户在自己的域里面为服务器分配的名称，是用户可以任意分配的。

**分级查询**：从根域名开始，依次查询每一级域名的NS记录，直到查到最终的IP地址。根域名服务器的IP地址的NS记录和IP地址一般不变，内置在DNS服务器中。

 域名与IP之前的对应关系称为**记录**，记录分为不同的类型：

（1） A：地址记录（Address），返回域名指向的IP地址。

（2） NS：域名服务器记录（Name Server），返回保存下一级域名信息的服务器地址。该记录只能设置为域名，不能设置为IP地址。

（3）MX：邮件记录（Mail eXchange），返回接收电子邮件的服务器地址。

（4）CNAME：规范名称记录（Canonical Name），返回另一个域名，即当前查询的域名是另一个域名的跳转。

（5）PTR：逆向查询记录（Pointer Record），只用于从IP地址查询域名。

## 1.11 DHCP

**ip地址是如何自动获取的？**

客户端发送广播，广播的目的 **ip 是 255.255.255.255，目的端口是 68**，为了让别人知道它是来请求一个 ip 的，我们的客户端会把 **0.0.0.0 作为自己的源 ip，源端口是 67**。意在告诉别人：我现在啥也没有，急需一个 ip，哪位老铁能给我提供一个 ip。我们把这个请求 ip 的报文称之为 **discover 报文**。

DHCP响应：当 DHCP 服务器收到这个报文之后，一看源地址是 0.0.0.0，知道这是一个请求 ip 的报文，DHCP 服务器就会给它提供一个 ip，包括 **ip 地址，子码掩码，网关，ip 的有效期等信息**。

**如何把ip交给客户端？**

在 discover 报文中，就会包含客户端的 MAC 地址。DHCP 服务器只需要发一个广播报文就可以了，广播报文的源ip是 DHCP 服务器自己的 ip，源端口是 67，目的地址是 255.255.255.255，目的端口是 68。我们把 DHCP 提供 ip 地址的报文称之为**offer报文**。

**客户端挑选ip地址：**有可能不止一台服务器收到了discover请求报文，客户端可能收到多个offer报文，客户端一般会选择最先收到的offer报文，选择好之后，会给对应的 DHCP 服务器次发送一个 **request 报文**，意在告诉它，我看中了你的报文。DHCP 收到 request 报文之后，会给它回复一个 ACK 报文，并且把这个分配出去的 ip 进行登记（例如把这个 ip 标记为已使用状态）。主机收到ACK报文后，就可以上网冲浪了。

**如果DHCP服务器不在局域网**，discover 报文 就会通过我们的网关来进行传递，并且会把源 ip 替换成网络的 ip，源端口是 68。DHCP 服务器收到报文之后，就可以根据源端口 68 来判断这是一个 discover 请求报文了。就会把 offer 发给网关，网关再发给我们的主机。

**租期：**在DHCP客户端的租约时间到达 1/2 时，客户端会向为它分配 IP 地址的DHCP服务器发送 request 单播报文，以进行 IP 租约的更新。如果服务器判断客户端可以继续使用这个 IP 地址，就回复 ACK 报文，通知客户端更新租约成功。如果此IP地址不能再分配给客户端，则回复 NAK 报文，通知客户端续约失败。如果客户端在租约到达 1/2 时续约失败，客户端会在租约到 7/8 时间时，广播发送 request 报文进行续约。DHCP服务器处理同首次分配 IP 地址的流程。

## 1.12 广播路由算法

**广播风暴**：当节点形成圈时，节点之间不停着发送广播分组，这时网络上充斥着大量重复的广播分组，这将会严重影响资源的利用。

**控制广播风暴**：给广播分组做标记。例如，源节点(发起广播的节点)可以将其**地址**以及**广播序号**放入这个广播分组中，然后发送给他的所有邻居节点，每个节点会维护它已经收到的、转发的源地址和广播分组的序号列表。当节点收到一个广播分组时，会检查这个广播分组是否之前接收过(可以通过源地址、报文序号来检查)，如果接收过，那么就把该广播分组丢弃，否则，把该广播分组接收，且向所有邻居节点转发。

**生成树广播**：上面的方法会存在很多的冗余分组(那些被丢弃的广播分组就是冗余的广播分组)，最理想的情况是找到最小生成树，让广播报文在最小生成树的路径中传送。先选出一个中心节点，然后其他节点向这个中心节点发送**加入树报文**，加入树报文经过的路径，都会被嫁接到生成树上。

<img src="https://shuaidi-picture-1257337429.cos.ap-guangzhou.myqcloud.com/picture/image-20220103220614286.png" alt="image-20220103220614286" style="zoom:50%;" />

## 1.13 SQL注入攻击

SQL注入：通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，服务器拿到这个字符串之后，会把这个字符串作为 sql 的执行参数去数据库查询，然而这个参数是**恶意**的，以至于服务器执行这条 sql 命令之后，出现了问题。

应对方法：

1. 参数绑定：使用预编译手段，绑定参数是最好的防SQL注入的方法。目前许多的ORM框架及JDBC等都实现了SQL预编译和参数绑定功能，攻击者的恶意SQL会被当做SQL的参数而不是SQL命令被执行。在mybatis的mapper文件中，对于传递的参数我们一般是使用 `#` 和`$`来获取参数值。
2.  使用正则表达式过滤传入的参数，例如把出现双`-`的过滤掉等等。

## 1.14 XSS攻击？

**XSS攻击**是指恶意攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些脚本代码嵌入到web页面中去，使别的用户访问都会执行相应的嵌入代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。

**危害**：盗取各类用户帐号；控制企业数据；非法转账；强制发送电子邮件

**原因：**过分信任客户端提交的数据，对用户所提交的数据过滤不足。

解决方法：将重要的cookie标记为http only, 这样的话Javascript 中的document.cookie语句就不能获取到cookie了；表单数据规定值的类型；对数据进行Html Encode 处理；过滤或移除特殊的Html标签；过滤JavaScript 事件的标签

## 1.15 NAT网络地址转换协议

IPV4的IP地址数量有限，内网中不要把每台电脑都分配ip地址。在我们这个内网里，我们可以指定自己的规则，例如，我们可以给这三台电脑随便分配三个IP(请注意，这三个IP不是去申请的，而且我自己随意给它分配的)。分别分配电脑A = 192.168.1.2 电脑B = 192.168.1.3 电脑C = 192.168.1.4。

为了让 A 可以访问百度，那么我们可以采取这样的方法：让网关去帮助 A 访问，然后百度把结果传递给网关，而网关再把结果传递给 A。在访问时，把 A的IP + 端口 映射成 网关的IP+端口就可以区分是A、B、C哪个访问。

<img src="https://shuaidi-picture-1257337429.cos.ap-guangzhou.myqcloud.com/picture/640-20210910201543272.jpeg" alt="图片" style="zoom:67%;" />

## 1.16 区分LAN、WAN、WLAN、VLAN、VPN

**1、局域网LAN和广域网WAN**

公司办公室内部的网络。短距离称为局域网LAN，长距离称为广域网WAN。

**2、无线局域网WLAN**

与广域网WAN的区别是，WAN采用网线连接，WLAN采用无线。

**3、虚拟局域网VLAN**

在没有VLAN技术之前，所有连接在同一台交换机的主机工作在一个广播域。但是往往这些主机并不在一个网段，而不同网段的主机不需要广播通信。为了防止收到不需要的广播信息，发明了VLAN技术，在交换机上将相同的网段的主机放在一个VLAN，一个VLAN对应一个广播域。

**4、虚拟私有网络VPN**

互联网是开放的、共享的，但是可以借助加密/解密技术，让互联网成为公司的私有网络，仿佛互联网是公司独有的。也可以理解为一种私有专线，但相比物理专线，价格要便宜一个数量级。

## 1.17 TCP和UDP

**传输控制协议 TCP**（Transmission Control Protocol）：面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。首部字段：20个字节，序号seq、确认号ack、数据偏移(首部长度)、确认ack、同步SYN、终止FIN、窗口。

**用户数据报协议 UDP**（User Datagram Protocol）：无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。例如：视频传输、实时通信。 **首部字段**只有 8 个字节，包括源端口、目的端口、长度、检验和。

**区别：**

(1)TCP是可靠传输,UDP是不可靠传输;

(2)TCP面向连接,UDP无连接;

(3)TCP传输数据有序,UDP不保证数据的有序性;

(4)TCP不保存数据边界,UDP保留数据边界;

(5)TCP传输速度相对UDP较慢;

(6)TCP有流量控制和拥塞控制,UDP没有;

(７)TCP是重量级协议,UDP是轻量级协议;

(８)TCP首部20字节,UDP首部8字节;

**基于TCP、UDP的常用协议：**

**TCP：**TTP、HTTPS、FTP、TELNET、SMTP(简单邮件传输协议)协议；

**UDP：**DNS、DHCP、TFTP、SNMP(简单网络管理协议)、RIP。

## 1.18 GET和POST的区别？各自使用场景？

- GET 被强制服务器支持
- 浏览器对URL的长度有限制，所以GET请求不能代替POST请求发送大量数据
- GET请求发送数据更小
- GET请求是不安全的
- GET请求是幂等的
  - 幂等的意味着对同一URL的多个请求应该返回同样的结果
- POST请求不能被缓存
- POST请求相对GET请求是「安全」的
  - 这里安全的含义仅仅是指是非修改信息
- GET用于信息获取，而且是安全的和幂等的
  - 所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。
- POST是用于修改服务器上的资源的请求
- 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠

## 1.19 ABC类地址和私有地址

A类地址(1~126)：网络号占前8位，以0开头，主机号占后24位。

B类地址(128~191)：网络号占前16位，以10开头，主机号占后16位。

C类地址(192~223)：网络号占前24位，以110开头，主机号占后8位。

D类地址(224~239)：以1110开头，保留位多播地址。

E类地址(240~255)：以1111开头，保留位今后使用

## 1.20 在浏览器中输入 URL 地址到显示主页的过程？

1. DNS 解析：浏览器查询 DNS，获取域名对应的 IP 地址：具体过程包括浏览器搜索自身的 DNS 缓存、搜索操作系统的 DNS 缓存、读取本地的 Host 文件和向本地 DNS 服务器进行查询等。对于向本地 DNS 服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；
2. TCP 连接：浏览器获得域名对应的 IP 地址以后，浏览器向服务器请求建立链接，发起三次握手；
3. 发送 HTTP 请求：TCP 连接建立起来后，浏览器向服务器发送 HTTP 请求；
4. 服务器处理请求并返回 HTTP 报文：服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；
5. 浏览器解析渲染页面：浏览器解析并渲染视图，若遇到对 js 文件、css 文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。
6. 连接结束。





# 1.3 子网划分

## 1.4 IP数据报分片

## 1.5 TCP/UDP的特点和区别

## 1.6 TCP滑动窗口

## 1.7 拥塞控制以及快速重传

## 1.8 TCP的三次握手和四次挥手

## 1.9 路由选择