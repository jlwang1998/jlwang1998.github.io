---
title: 操作系统
date: 2022-07-19 10:00:00 +0800
categories: [八股,操作系统]
tags: [操作系统]
pin: true
author: 王家乐

toc: true
comments: true
typora-root-url: ../../jlwang1998.github.io
math: false
mermaid: true
---

# 1. 操作系统概述

## 1.1 操作系统的概念、功能和目标

<img src="/assets/blog_res/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220719100910352.png" alt="image-20220719100910352" style="zoom: 50%;" />

<img src="/assets/blog_res/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220719101047408.png" alt="image-20220719101047408" style="zoom:50%;" />

<img src="/assets/blog_res/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220719101244560.png" alt="image-20220719101244560" style="zoom:50%;" />

联机命令接口：交互式命令接口，如time

脱机命令接口：批处理命令接口

程序接口：.dll文件

##  1.2 操作系统的特征

并发、共享、虚拟、异步。并发和共享是两个最基本的特征，二者互为存在条件。

**并发**和**并行**不同：并发宏观上是同时发生的微观上是交替发生，并行是多个事件同时发生。

**共享**：资源共享，指系统中的资源可供内存中多个并发执行的进程共同使用。

- 互斥共享：一个时间段内只允许一个进程访问该资源。
- 同时共享：允许一个时间段内由多个进程**同时**对它们进行访问，（同时指的是宏观）

**虚拟**：指把一个物理上的实体变为若干个逻辑上的对应物。物理实体是实际存在的，而逻辑上对应物是用户感受到的。没有并发性，就谈不上虚拟性。

- 虚拟技术：空分复用技术（如虚拟存储器技术）、时分复用技术（如虚拟处理器）

**异步**：在多到程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进。（可能会阻塞）只有系统拥有并发性，才有可能导致异步性。

## 1.3 操作系统的发展与分类

**手工操作阶段**：打孔机（二进制），缺点：用户独占全机、人机速度矛盾导致资源利用率极低。

**批处理阶段**：

- 单通道批处理系统：引入脱机输入/输出技术（用磁带完成），并监督程序负责控制作业的输入输出。监督程序是操作系统的雏形。

  - 优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。

  - 缺点：内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序。CPU有大量的时间是在空闲等待I/O完成。资源利用率依然很低。

- 多道批处理系统：每次往内存中输入多道程序，操作系统正式诞生，并引入中断技术，由操作系统负责管理这些程序的运行。各个程序并发执行。
  - 优点：多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源保持忙碌状态，系统吞吐量增大。
  - 缺点：用户响应时间长，没有人机交互功能，（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行）

**分时操作系统**：计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互。

- 优点：解决了人机交互问题。
- 缺点：不能优先处理一些紧急任务。

**实时操作系统**：能优先响应一些紧急任务。主要特点是及时性和可靠性。

- 硬实时系统：必须在绝对严格的规定时间内完成处理（导弹控制系统、自动驾驶系统）
- 软实时系统：能接受偶尔违反时间规定（12306火车订票系统）

**网络操作系统**

**分布式操作系统**

**个人计算机操作系统**

## 1.4 操作系统的运行机制和体系结构

指令：

- 特权指令：如内存清零指令，不允许用户程序使用
- 非特权指令：如普通的运算指令

CPU如何判断当前是否可以执行特权指令？

- 处于用户态（目态）时，只能执行非特权指令；处于核心态（管态）时，都可以执行。

程序：

- 内核程序：是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态；
- 应用程序：只能执行非特权指令，运行在用户态。

<img src="/assets/blog_res/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220719113018037.png" alt="image-20220719113018037" style="zoom:50%;" />

<img src="/assets/blog_res/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220719113109676.png" alt="image-20220719113109676" style="zoom:50%;" />

## 1.5 中断和异常

引入 中断机制，实现了多道程序并发执行。

本质：发生中断意味着需要操作系统介入，开展管理工作。

操作系统的管理工作需要使用特权指令，因此CPU要从用户态转为核心态。中断可以使CPU从用户态切换为核心态，使操作系统获得计算机的控制权。

用户态和核心态是如何切换的？

- 用户态->核心态的切换是通过中断实现的，并且中断是唯一途径。核心态->用户态的切换是通过执行一个特权指令，将程序状态字（PSW）的标志位设置为“用户态”。

中断分类：

<img src="/assets/blog_res/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220719124709035.png" alt="image-20220719124709035" style="zoom:50%;" />

<img src="/assets/blog_res/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220719125136205.png" alt="image-20220719125136205" style="zoom: 50%;" />

## 1.6 系统调用

**系统调用**：操作系统提供给应用程序（程序员/编程人员）使用的接口，应用程序可以发出系统调用请求来获得操作系统的服务，系统调用会使处理器从用户态进入核心态。

凡是与资源有关的操作、会直接影响到其他进程的操作，一定需要操作系统介入，即需要通过系统调用来实现。

**为什么要提供系统调用功能？**

- 系统的共享资源由操作系统统一掌管，在用户程序中，凡是与资源有关的操作，都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。可以保证系统的稳定性和安全性，防止用户进行非法操作。

**系统调用与库函数的区别：**

<img src="/assets/blog_res/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220719130125070.png" alt="image-20220719130125070" style="zoom:50%;" />

系统调用是操作系统向上层提供的接口，有的库函数是对系统调用的进一步封装，当今编写的应用程序大多是通过高级语言提供的库函数间接地进行系统调用。

**系统调用的过程**：传递系统调用参数->执行陷入指令（用户态）->执行系统调用相应服务程序（核心态）->返回用户程序

系统调用发生在用户态，对系统调用的处理发生在核心态。执行陷入指令会产生中断，使处理器从用户态进入核心态。

# 2. 进程与线程

## 2.1 进程

**进程**：是进程实体的运动过程，是系统进行资源分配和调度的一个独立单位。（进程实体是静态的，进程是动态的）

系统为每个运行的程序配置一个数据结构，称为**进程控制块（PCB）**，用来描述进程的各种信息（如程序代码存放位置）。

程序段、数据段、PCB三部分组成了进程实体（进程）。PCB是进程存在的唯一标志。

<img src="/assets/blog_res/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220719132148134.png" alt="image-20220719132148134" style="zoom:50%;" />

**进程的组织**：多个进程之间的组织方式。

<img src="/assets/blog_res/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220719132408481.png" alt="image-20220719132408481" style="zoom:50%;" />

**进程的特征**：

<img src="/assets/blog_res/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220719132704343.png" alt="image-20220719132704343" style="zoom: 50%;" />

**进程的三种基本状态：**

<img src="/assets/blog_res/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220719142217299.png" alt="image-20220719142217299" style="zoom:50%;" />

<img src="/assets/blog_res/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220719142410088.png" alt="image-20220719142410088" style="zoom:50%;" />

**进程状态间的切换：**

<img src="/assets/blog_res/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220719142702138.png" alt="image-20220719142702138" style="zoom: 33%;" />

 **进程控制**：实现进程状态转换。用**原语**实现进程控制。原语的特点是执行期间不允许中断，只能一气呵成。原语采用“关中断指令“和”开中断指令“实现。（核心态）

<img src="/assets/blog_res/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220719143257610.png" alt="image-20220719143257610" style="zoom: 33%;" />

**原语所作的内容：**

- 更新PCB中的信息（修改进程状态、将运行环境保存到PCB、从PCB恢复运行环境）；
- 将PCB插入合适的队列；
- 分配/回收资源

**相关原语**：进程的创建、进程的终止、进程的阻塞、进程的唤醒、进程的切换。其中，阻塞和唤醒要成对出现。

**进程通信：**进程之间的信息交换。进程是分配系统资源的单位，因此各进程拥有的内存地址空间相互独立。

- **共享存储：**两个进程对共享空间的访问必须是互斥的。
  - 基于数据结构的共享：比如共享空间里只能放一个长度为10的数组，速度慢、限制多，低级通信。
  - 基于存储区的共享：在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。速度快，高级通信。
- **消息传递：**进程间的数据交换以**格式化的消息**为单位。进程通过操作系统提供的”发送消息/接收消息“两个原语进行数据交换。
  - 直接通信方式：消息直接挂到接收方的消息队列里；
  - 间接（信箱）通信方式：消息先发到中间体（信箱）。
- **管道通信：**
  - 管道：用于连接读写进程的一个共享文件。即在内存中开辟一个大小固定的缓冲区。
  - 只能采用半双工通信，某一时间段只能实现单向传输。如果要实现双向同时通信，需要设置两个管道。
  - 各进程互斥地访问管道。
  - 数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。
  - 如果没写满，就不允许读。如果没读空，就不允许写。
  - 数据一旦被读出，就从管道中抛弃。读进程最多只能有一个，否则会有读错数据的情况。

## 2.2 线程

**什么是线程？为什么要引入线程？**

- 线程是一个基本的CPU执行单元，也是程序执行流的最小单位。
- 有的进程可能需要”同时“做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了”线程“，来增加并发度。

**引入线程机制后，有什么变化？**

<img src="/assets/blog_res/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220719150232817.png" alt="image-20220719150232817" style="zoom: 33%;" />

**线程的属性：**

<img src="/assets/blog_res/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220719150419246.png" alt="image-20220719150419246" style="zoom:33%;" />

**线程的实现方式：**

- **用户级线程：**由应用程序通过线程库实现。所有的线程管理工作都由**应用程序**负责（包括线程切换）；用户级线程中，线程切换可以在**用户态**下即可完成，无需操作系统干预；用户级线程对用户不透明，对操作系统透明。
- **内核级线程：**线程的管理工作由**操作系统内核**完成。线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在**核心态**下才能完成。内核级线程是处理机分配的单位。

**多线程模型：**

- 多对一模型：多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。
  - 优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高；
  - 缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个进程不可在多核处理机上并行运行。
- 一对一模型：一个用户及线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。
  - 优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。
  - 缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。
- 多对多模型：n用户及线程映射到m个内核级线程(n>=m)。每个用户进程对应m个内核级线程。

## 2.3 处理机调度

**调度：**当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。需要确定某种规则来决定处理这些任务的顺序。

**处理机调度：**在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。处理机调度就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。

- **高级调度（作业调度）：**调入。
- **中级调度（内存调度）：**暂时调到外存等待的进程状态为**挂起状态**。中级调度就是要决定将哪个处于挂起状态的进程重新调入内存。


<img src="/assets/blog_res/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220719153015350.png" alt="image-20220719153015350" style="zoom: 33%;" />

- **低级调度（进程调度）：**按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。最基本的一种调度。频率很高。

**三种调度的联系、对比：**

<img src="/assets/blog_res/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220719153320198.png" alt="image-20220719153320198" style="zoom:33%;" />

### 2.3.1 进程调度（低级调度）（不是重点）

**进程调度的时机：**

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720094841005.png" alt="image-20220720094841005" style="zoom: 33%;" />

**进程调度的方式：**

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720112939168.png" alt="image-20220720112939168" style="zoom:33%;" />

 **进程切换：**指一个进程让出处理机，由另一个进程占用处理机的过程。

**进程切换的过程完成了**：对原来运行进程各种数据的保存；对新的进程各种数据的恢复。

> 注意：进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。

### 2.3.2 调度算法的评价指标

**CPU利用率：**指CPU”忙率“的时间占总时间的比例。

**系统吞吐量：**单位时间内完成作业的数量。

**周转时间：**指从作业被提交给系统开始，到作业完成作业为止的时间。包括：作业在外存后备队列上等待作业调度（高级调度）的时间、进程在就绪队列上等待进程调度（低级调度）的时间、进程在CPU上执行的时间、进程等待I/O操作完成的时间。

**带权周转时间：**作业周转时间/作业实际运行的时间。

**等待时间：**指进程/作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。

**响应时间：**指从用户提交请求到首次产生响应所用的时间。

### 2.3.3 调度算法

**先来先服务（FCFS）**：按照到达的先后顺序调度。

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720144113219.png" alt="image-20220720144113219" style="zoom:33%;" />

**短作业优先（SJF）：**每次调度时选择当前已到达且运行时间最短的作业/进程。（抢占式和非抢占式）

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720150200609.png" alt="image-20220720150200609" style="zoom:33%;" />

**高响应比优先（HRRN）：**在每次调度时先计算各个作业/进程的响应比，选择响应比最高难顶作业/进程为其服务。（响应比=等待时间+要求服务时间/要求服务时间）。**非抢占式**，只有当前运行的进程主动放弃CPU（正常/异常完成，或主动阻塞），才需要进行调度，调度时计算所有就绪进程的响应比，选响应比最高的进程上处理机。

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720150755958.png" alt="image-20220720150755958" style="zoom:33%;" />

**时间片轮转（RR）：**按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100 ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。常用于分时操作系统，更注重"响应时间"。（抢占式）

- 一般，设计时间片时要让切换进程的开销占比不超过1%。
- 如果**时间片太大**，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。
- 如果**时间片太小**，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720152206647.png" alt="image-20220720152206647" style="zoom:33%;" />

**优先级调度算法：**每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程。（抢占式和非抢占式）

- 静态优先级：创建进程时确定，之后一直不变。
- 动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级。
- 如何合理设置各类进程的优先级？
  - 通常，系统进程优先级高于用户进程；前台进程优先级高于后台进程；操作系统更偏好I/O型进程（I/O繁忙型进程）。

- 如果采用动态优先级，什么时候应该调整？
  - 可以从追求公平、提升资源利用率等角度考虑。如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级；如果某进程占用处理机运行了很长时间，则可适当降低其优先级。

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720153226332.png" alt="image-20220720153226332" style="zoom:33%;" />

**多级反馈队列调度算法：**（对其他调度算法的折中权衡，抢占式）

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720154715171.png" alt="image-20220720154715171" style="zoom:33%;" />

## 2.4 进程同步、进程互斥

**同步：**直接制约关系，指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。

**临界资源：**一个时间段内只允许一个进程使用的资源。对临界资源的访问，必须**互斥**地进行。

**互斥：**间接制约关系，当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720155934982.png" alt="image-20220720155934982" style="zoom:33%;" />

**进程互斥的原则：**

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720160052117.png" alt="image-20220720160052117" style="zoom:33%;" />

### 2.4.1 进程互斥的软件实现方法

**单标志法：** 两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予。

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720162157356.png" alt="image-20220720162157356" style="zoom:33%;" />

**双标志先检查法：**设置一个布尔数组flag[]，数组中各个元素用来标记各进程想进入临界区的意愿，比如”flag[0]=true“意味着0号进程P0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[i]设为true，之后开始访问临界区。

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720162738200.png" alt="image-20220720162738200" style="zoom:33%;" />

**双标志后检查法：**先上锁后检查。

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720162931097.png" alt="image-20220720162931097" style="zoom:33%;" />

**Peterson算法：**如果两个进程都想争着进入临界区，那可以让进程尝试”孔融让梨“，主动让对方先使用临界区。

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720165017699.png" alt="image-20220720165017699" style="zoom:33%;" />

解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是未遵循让权等待原则。

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720170600407.png" alt="image-20220720170600407" style="zoom:50%;" />

### 2.4.2 进程互斥的硬件实现方法

**中断屏蔽方法：**利用”开/关中断指令“实现。关中断即不允许当前进程被中断，也必然不会发生进程切换；直到当前进程访问完临界区，再执行开中断指令，才有可能有别的进程上处理机并访问临界区。

- 优点：简单、高效
- 缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程。

**TestAndSet（TS）指令：**用硬件实现，执行的过程不允许被中断，只能一气呵成。

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720192838267.png" alt="image-20220720192838267" style="zoom:33%;" />

**Swap指令：**用硬件实现，执行的过程不允许被中断，只能一气呵成。逻辑上与TSL一致。

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720193023746.png" alt="image-20220720193023746" style="zoom:33%;" />

## 2.5 信号量机制

**信号量：**一个变量，表示系统中某种资源的数量。如：系统中只有一台打印机，就可以设置为一个初值为1的信号量。

用户进程可以通过使用操作系统提供的**一对原语**来对**信号量**进行操作。

**一对原语：**wait(S)原语和signal(S)原语，简称P，V操作，括号里的信号量S就是函数调用时传入的参数。

**整型信号量：**用一个整数型的变量作为信号量。

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720195624963.png" alt="image-20220720195624963" style="zoom:33%;" />

**记录型信号量：**用记录型数据结构表示的信号量。

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720195941246.png" alt="image-20220720195941246" style="zoom:33%;" />

**信号量机制实现进程互斥：**

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720201151197.png" alt="image-20220720201151197" style="zoom:33%;" />

**信号量机制实现进程同步：**

- 分析什么地方需要实现”同步关系“，即必须保证”一前一后“执行的两个操作；
- 设置同步信号量S，初始为0；
- 在”前操作“之后执行V(S)；
- 在”后操作“之前执行P(S)。

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720201745703.png" alt="image-20220720201745703" style="zoom:33%;" />

**信号量机制实现前驱关系：**

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720202158364.png" alt="image-20220720202158364" style="zoom:33%;" />

## 2.6 经典的进程同步、进程互斥问题

### 2.6.1 生产者-消费者问题

**问题分析：**

- 系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区取出一个产品并使用。生产者、消费者共享一个初始为空、大小为n地缓冲区。只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。缓冲区是临界资源，各进程必须**互斥**地访问。

**PV操作题目分析步骤：**

- 关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。
- 整理思路。根据各进程的操作流程确定P、V操作的大致顺序。
- 设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。（互斥信号量初值一般为1，同步信号量的初始值要看对于资源的初始值是多少）

**如何用信号量机制实现生产者、消费者进程地这些功能？**

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720204358359.png" alt="image-20220720204358359" style="zoom:33%;" />

**能否改变相邻P、V操作的顺序？**

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720204608547.png" alt="image-20220720204608547" style="zoom:33%;" />

### 2.6.2 多生产者-多消费者问题

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720204941527.png" alt="image-20220720204941527" style="zoom: 50%;" />

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720205337211.png" alt="image-20220720205337211" style="zoom:33%;" />

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720205641232.png" alt="image-20220720205641232" style="zoom:33%;" />

如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。

### 2.6.3 吸烟者问题

![image-20220720210538525](/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720210538525.png)

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720210810305.png" alt="image-20220720210810305" style="zoom:33%;" />

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720211156362.png" alt="image-20220720211156362" style="zoom:33%;" />

### 2.6.4 读者-写者问题

![image-20220720211440194](/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720211440194.png)

**核心思想：**设置一个**计数器coun**t来记录当前正在访问共享文件的读进程数。

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720212213595.png" alt="image-20220720212213595" style="zoom:33%;" />

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720212540937.png" alt="image-20220720212540937" style="zoom:33%;" />

### 2.6.5 哲学家进餐问题

![image-20220720212744334](/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720212744334.png)

**关键在于：解决进程死锁。**

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720212916841.png" alt="image-20220720212916841" style="zoom: 50%;" />

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720213213219.png" alt="image-20220720213213219" style="zoom:50%;" />

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720214144497.png" alt="image-20220720214144497" style="zoom:50%;" />

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720214541315.png" alt="image-20220720214541315" style="zoom: 50%;" />

## 2.7 管程

信号量机制存在问题：编写程序困难、易出错。

引入管程就是更方便地实现进程互斥和同步。

**管程：**是一种特殊的软件模块（类似C++类）。有以下部分组成：

- 局部于管程的**共享数据结构**说明；
- 对该数据结构进行操作的**一组过程**（过程就是函数）；
- 对局部于管程的共享数据设置初始值的语句；
- 管程有一个名字。

**管程的基本特征：**（常考）

- 局部于管程的数据只能被局部于管程的过程所访问；
- 一个进程只有通过调用管程内的过程才能进入管程访问共享数据；
- 每次仅允许一个进程在管程内执行某个内部过程。

 **用管程解决生产者消费者问题：**

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220720215829431.png" alt="image-20220720215829431" style="zoom:50%;" />

## 2.8 死锁

**死锁：**在并发环境下，各进程因竞争资源而造成的一种**互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象**。如五个科学家拿筷子吃饭，同时拿起了左手边的筷子，都拿不到右手边的筷子。

**饥饿：**由于长期得不到想要的资源，某进程无法向前推进的现象。比如：在短进程优先算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。

**死循环：**某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致，有时是程序员故意设计的。

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721092116929.png" alt="image-20220721092116929" style="zoom:33%;" />

**死锁产生的必要条件：**

- **互斥条件：**只有对必须互斥使用的资源的争抢才会导致死锁。
- **不剥夺条件：**进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。
- **请求和保持条件：**进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。
- **循环等待条件**：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。

**什么时候会发生死锁？**

- 对系统资源的竞争。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源（CPU）的竞争是不会引起死锁的。
- 进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。
- 信号量的使用不当也会造成死锁。

**死锁的处理策略：**

- 预防死锁。破坏死锁产生的四个必要条件中的一个或几个。
- 避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）
- 死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。

### 2.8.1 死锁的处理策略——预防死锁

**互斥条件：**只有对必须互斥使用的资源的争抢才会导致死锁。

- 把只能互斥使用的资源改造为允许共享使用，如SPOOLing技术。
- **缺点：**并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，很多时候都无法破坏互斥条件。

**不剥夺条件：**进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。

- 方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。
- 方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级。
- 缺点：
  - 实现起来复杂；
  - 释放已获得的资源可能造成前一阶段工作的失效。只适用于易保存和恢复状态的资源，如CPU。
  - 反复地申请和释放资源会增加系统开销，降低系统吞吐量。
  - 若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿。

**请求和保持条件：**进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。

- 采用**静态分配方法**，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。
- **缺点：**有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，**资源利用率极低**。另外，该资源也有可能导致某些**进程饥饿**。

**循环等待条件**：存在一种进程资源的**循环等待链**，链中的每一个进程已获得的资源同时被下一个进程所请求。

- 采用**顺序资源分配法**。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完。
- **原理分析：**一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。
- **缺点：**不方便增加新的设备，因为可能需要重新分配所有的编号；进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费；必须按规定次序申请资源，用户编程麻烦。

### 2.8.2 死锁的处理策略——避免死锁

**安全序列：** 如果系统按照这种序列分配资源，则每个进程都能顺序完成。只要能找出一个安全序列，系统就是安全状态。安全序列可能有多个。

如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就有可能发生死锁。

**银行家算法的核心思想：**在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721101838574.png" alt="image-20220721101838574" style="zoom:33%;" />

**银行家算法步骤：**

- 检查此次申请是否超过了之前声明的最大需求数；
- 检查此时系统剩余的可用资源是否还能满足这次请求；
- 试探着分配，更改各数据结构；
- 用安全性算法检查此次分配是否会导致系统进入不安全状态。

### 2.8.3 死锁的处理策略——检测和解除

**死锁的检测：**

- 用某种数据结构来保存资源的请求和分配信息；
- 提供一种**算法**，利用上述信息来检测系统是否已进入死锁状态。

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721102349899.png" alt="image-20220721102349899" style="zoom: 50%;" />

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721102655413.png" alt="image-20220721102655413" style="zoom:50%;" />

如果能消除所有的边，就称这个图是**可完全简化**的，此时一定没有发生死锁。

如果最终不能消除所有边，那么此时就是发生了死锁。

**检测死锁的算法：**依次消除与不阻塞进程相连的边，直到无边可消。

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721103028275.png" alt="image-20220721103028275" style="zoom:50%;" />

**死锁定理：**如果某时刻系统的资源分配图是不可完成简化的，那么此时系统死锁。

**死锁的解除：**

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721103244100.png" alt="image-20220721103244100" style="zoom:50%;" />

**如何决定“对谁动手”？**

- 进程优先级
- 已执行多长时间；
- 还要多久能完成；
- 进程已经使用了多少资源；
- 进程是交互式的还是批处理式的

# 3. 内存管理

**内存：**用于存放数据的硬件。程序执行前需要先放到内存中才能被CPU处理。

**如何区分各个程序的数据是放在什么地方的？**

- 给内存的存储单元编地址，内存地址从0开始，每个地址对应一个存储单元。

```
2^10=1K(千)
2^20=1M(兆，百万)
2^30=1G(十亿，千兆)
```

编译生成的指令一般使用**逻辑地址（相对地址）**。

**从写程序到程序运行：**

1. 编辑：*.c
2. 编译：*.o，由编译程序将用户源代码编译成若干个目标模块（编译就是把高级语言翻译为机器语言）
3. 链接：*.exe，由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块；
4. 装入（装载）：由装入程序将装入模块装入内存运行。

**链接的三种方式：**

- 静态链接：在程序运行之前，先将各目标模块及他们所需的库函数连接成一个完成的可执行文件（装入模块），之后不再拆开；
- 装入时动态链接：将各目标模块装入内存时，边装入边链接；
- 运行时动态链接：在程序执行中需要该目标模块时，才对它进行链接。优点是便于修改和更新，便于实现对目标模块的共享。

**装入的三种方式**（用三种不同的方法完成**逻辑地址到物理地址的转换**）：

- **绝对装入：**在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存**。只适用于单道程序环境**。一般情况下都是编译或汇编时再转换为绝对地址。
- **静态重定位（可重定位装入）：**编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）。（**早期多道批处理阶段**）
  - **特点：**在一个作业装入内存时，必须**分配其要求的全部内存空间**，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，**在运行期间就不能再移动**，也不能再申请内存空间。
- **动态重定位（动态运行时装入）：**编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是**把地址转换推迟到程序真正要执行时才进行**。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个**重定位寄存器**的支持。（**现代操作系统**）
  - **重定位寄存器：**存放装入模块存放的起始位置。
  - **特点：**允许程序在内存中发生移动。可将程序分配到不连续的存储区中；在程序运行期只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。

## 3.1 内存管理的概念

**内存管理负责的内容：**

- 内存空间的分配与回收；
- 提供某种技术从逻辑上对内存空间进行扩充；
- 提供地址转换功能，负责程序的逻辑地址与物理地址的转换；
- 提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰。
  - 方法一：在CPU中设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检测是否越界；
  - 方法二：采用重定位寄存器和界地址寄存器进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。

### 3.1.1 内存空间的扩充——覆盖与交换（不重要）

**覆盖技术：**用来解决”程序大小超过物理内存总和“的问题。

- **覆盖技术的思想：**将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时调入内存。内存中分为一个“**固定区**”和若干个“**覆盖区**”。需要常驻内存的段放在“固定区”中，调入后不再调出（除非运行结束）；不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存。
- **特点：**必须由程序员声明覆盖结构，操作系统完成自动覆盖。缺点：对用户不透明，增加了用户编程负担。覆盖技术只用于早期的操作系统中。

**交换技术：**内存空间紧张时，系统将内存中某些进程暂时**换出**外存，把外存中某些已具备运行条件的进程换入**内存**（进程在内存与磁盘间动态调度）

- 暂时换出外存等待的进程状态为**挂起状态**（挂起态，suspend），挂起态分为就绪挂起、阻塞挂起。

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721144654543.png" alt="image-20220721144654543" style="zoom:33%;" />

**覆盖与交换的区别：**

覆盖是在同一个程序或进程中的，交换是在不同进程（或作业）之间的。

### 3.1.2 内存空间的分配与回收——连续分配管理方式

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721145243812.png" alt="image-20220721145243812" style="zoom:50%;" />

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721151450858.png" alt="image-20220721151450858" style="zoom:50%;" />

**连续分配：**指为用户进程分配的必须是一个连续的内存空间。

**单一连续分配：**

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721145510800.png" alt="image-20220721145510800" style="zoom:33%;" />

**固定分区分配：**

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721145821064.png" alt="image-20220721145821064" style="zoom:33%;" />

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721150005926.png" alt="image-20220721150005926" style="zoom:33%;" />

**动态分区分配：**

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721150204608.png" alt="image-20220721150204608" style="zoom: 50%;" />

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721150412626.png" alt="image-20220721150412626" style="zoom: 50%;" />

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721150543791.png" alt="image-20220721150543791" style="zoom:50%;" />

**3. 如何进行分区的分配与回收操作？**

- 更改空闲分区表的分区大小和起始地址即可。

动态分区分配没有**内部碎片**，但是有**外部碎片**。可以通过**紧凑**技术来解决外部碎片。

- **内部碎片：**分配给某进程的内存区域中，如果有些部分没有用上。
- **外部碎片：**是指内存中的某些空闲分区由于太小而难以利用。

#### 动态分区分配算法

**动态分区分配算法：**在动态分区分配方式中，当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？

- **首次适应算法：**每次都从低地址开始查找，找到第一个能满足大小的空闲分区。
  - **如何实现：空闲分区以地址递增的次序排列**。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。
- **最佳适应算法：**由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当”大进程“到来时能有连续的大片空间，就可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区。
  - **如何实现：**空闲分区按**容量递增**次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。
  - **缺点：**每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片。
- **最坏适应算法：**在每次分配时优先使用最大的连续空闲区。
  - **如何实现：**空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。
  - **缺点：**每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有”大进程“到达，就没有内存分区可用了。
- **邻近适应算法：**首次适应算法每次都从链头开始查找。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。
  - **如何实现：**空闲分区以地址递增的顺序排列（可排列一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721154003334.png" alt="image-20220721154003334" style="zoom:50%;" />

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721154031588.png" alt="image-20220721154031588" style="zoom:50%;" />

### 3.1.3 内存空间的分配与回收——非连续分配管理方式

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721154407749.png" alt="image-20220721154407749" style="zoom:50%;" />

#### 基本分页存储管理

**思想：**把内存分为一个个相等的小分区，再按照分区大小把进程拆分成一个个小部分。

将内存空间分为一个个大小相等的分区，每个分区就是一个”**页框“**（或称为页帧、内存块、物理块），每个页框有一个编号，即：页框号”，页框号从0开始。

将用户进程的地址空间也分为**与页框大小相等**的一个个区域，称为“**页**”或“**页面**”。每个页面也有一个编号，即“**页号**”，页号也是从0开始。（进程的最后一个页面可能没有一个页框那么大。因此，页框不能太大，否则可能产生过大的内部碎片）

操作系统**以页框为单位为各个进程分配**内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的**页面**与内存的**页框**有**一一对应**的关系。各个页面不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中。

**将进程地址空间分页之后，操作系统该如何实现逻辑地址到物理地址的转换？**

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721160949575.png" alt="image-20220721160949575" style="zoom:33%;" />

如果每个页面大小为$2^kB$，用二进制数表示逻辑地址，则末尾K位即为**页内偏移量**，其余部分就是**页号**。

**页表：**记录进程页面和实际存放的内存块之间的对应关系。一个进程对应一张页表，进程的每一页对应一个页表项，每个页表项由**页号**和**块号**组成。每个页表项的长度是相同的，页号是“隐含”的。

##### 基本地址变换机构（重要）

用于实现逻辑地址到物理地址转换的一组硬件机构。

通常会在系统中设置一个**页表寄存器**（PTR），存放**页表在内存中的起始地址F和页表长度M**。进程未执行时，页表的始址和页表长度**放在进程控制块（PCB）**中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721163714514.png" alt="image-20220721163714514" style="zoom:50%;" />

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721164241854.png" alt="image-20220721164241854" style="zoom:50%;" />

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721164747955.png" alt="image-20220721164747955" style="zoom:50%;" />

##### 具有快表的地址变换机构

是基本地址变换机构的改进版本。

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721165613896.png" alt="image-20220721165613896" style="zoom: 50%;" />

**快表**，又称**联想寄存器（TLB）**，是一种访问速度比内存快很多的高速缓冲寄存器，用来存放当前访问的若干页表项，以加速地址变换的股票池。与此对应，内存中的页表常称为**慢表**。

**引入快表后，地址的变换过程：**

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721170104325.png" alt="image-20220721170104325" style="zoom: 33%;" />

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721170343405.png" alt="image-20220721170343405" style="zoom: 50%;" />

##### 两级页表

**单级页表存在的问题：**

- 页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721171719754.png" alt="image-20220721171719754" style="zoom:50%;" />

- **如何实现地址变换？**

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721171838419.png" alt="image-20220721171838419" style="zoom:50%;" />

- 没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。
  - 在需要访问页面时才把页面调入内存（虚拟存储技术）。可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存。若想访问的页面不在内存中，则产生缺页中断（内中断），然后将目标页面从外存调入内存。

**需要注意的几个细节：**

- 若采用多级页表机制，则**各级页表的大小不能超过一个页面**。
- 两级页表的**访存次数**分析（假设没用快表机构）
  - 第一次访存：访问内存中的页目录表；
  - 第二次访存：访存内存中的二级页表；
  - 第三次访存：访问目标内存单元

#### 基本分段存储管理方式

与“分页”最大的区别就是离散分配时所**分配地址空间的基本单位**不同。

**进程的地址空间：**按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名（在低级语言中，程序员使用段名来编程），每段从0开始编址。

**内存分配规则：**以段为单位，每个段在内存中占据连续空间，但各段之间可以不相邻。

分段系统的**逻辑地址**由段号（段名）和段内地址（段内偏移量）所组成。

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721173803177.png" alt="image-20220721173803177" style="zoom: 33%;" />

**段表：**为了保证程序能正常运行，必须能从物理内存中找到各个逻辑段的存放位置。因此，需要为每个进程建立一张**段映射表**。

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721174149018.png" alt="image-20220721174149018" style="zoom:33%;" />

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721185217095.png" alt="image-20220721185217095" style="zoom: 33%;" />

**分段、分页管理的对比：**

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721190312073.png" alt="image-20220721190312073" style="zoom:50%;" />

**为什么分段比分页更容易实现信息的共享和保护？**

- 因为页面不是按逻辑模块划分的。

#### 段页式管理方式

**分页、分段的优缺点分析：**

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721190508088.png" alt="image-20220721190508088" style="zoom:50%;" />

**采用分段+分页的段页式管理：**将进程按逻辑模块分段，再将各段分页（如每个页面4KB），再将内存空间分为大小相同的内存块/页框/页帧/物理块，进程前将各页面分别装入各内存块中。

段页式系统的**逻辑地址结构**由段号、页号、页内地址（页内偏移量）组成。

段号的位数决定了每个进程最多可以分几个段，页号位数决定了每个段最大有多少页，页内偏移量决定了页面大小、内存块大小是多少。

“分段”对用户是可见的，程序员编程时需要显式地给出段号、段内地址。而将各段“分页”对用户是不可见的。系统会根据段内地址自动划分页号和页内偏移量。因此，**段页式**管理的**地址结构是二维的**。

每个段对应一个段表项，每个段表项由**段号、页表长度、页表存放块号**（页表起始地址）组成。每个段表项长度相等，段号是隐含的。

每个页面对应一个页表项，每个页表项由页号、页面存放的内存块号组成。每个页表项长度相等，页号是隐含的。

**地址变换：**

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721193127680.png" alt="image-20220721193127680" style="zoom: 50%;" />

## 3.2 虚拟内存管理

**传统存储管理方式的特征、缺点：**

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721193715310.png" alt="image-20220721193715310" style="zoom:50%;" />

**虚拟内存的定义和特征：**

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721194255125.png" alt="image-20220721194255125" style="zoom:50%;" />

**虚拟内存的三个主要特征：**

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721194345375.png" alt="image-20220721194345375" style="zoom:50%;" />

**如何实现虚拟内存技术？**

虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配方式，会不方便实现。因此，虚拟内存的实现需要建立在**离散分配**的内存管理方式基础上。

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721194612677.png" alt="image-20220721194612677" style="zoom:50%;" />

### 3.2.1 请求分页存储管理

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721194832794.png" alt="image-20220721194832794" style="zoom:50%;" />

**页表机制：**

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721195059521.png" alt="image-20220721195059521" style="zoom:50%;" />

**缺页中断机构：**

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721195304897.png" alt="image-20220721195304897" style="zoom:50%;" />

**缺页中断**是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于**内中断**。

一条指令在执行期间，可能产生多次缺页中断。

**地址变换机构：**

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721200037156.png" alt="image-20220721200037156" style="zoom:50%;" />

**与基本分页不同之处：**

- 找到页表项是需要检查页面是否在内存中；
- 若页面不在内存中，需要请求调页；
- 若内存空间不够，还需换出页面；
- 页面调入内存后，需要修改相应页表项。

#### 页面置换算法

页面的换入、换出需要磁盘I/O，会有较大的开销，因此好的页面置换算法应该**追求更少的缺页率**。

**最佳置换算法（OPT）：**每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。缺页率=缺页中断的次数/访问次数。

- 最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，**最佳置换算法是无法实现的**。

**先进先出置换算法（FIFO）：**每次选择淘汰的页面是最早进入内存的页面。

- **实现方法：**把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块。
- **Belady异常：**当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。
- **只有FIFO算法会产生Belady异常**。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，**算法性能差**。

**最近最久未使用置换算法（LRU）：**每次淘汰的页面是最近最久未使用的页面。

- **实现方法：**赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。
- 该算法的实现需要专门的硬件支持，虽然**算法性能好**，但是**实现困难，开销大**。

**时钟置换算法（CLOCK）：**性能和开销较为均衡的算法，又称为最久未用算法（NRU）。

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721202721141.png" alt="image-20220721202721141" style="zoom:50%;" />

**改进型的时钟置换算法：**

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721203837400.png" alt="image-20220721203837400" style="zoom:50%;" />

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721204130983.png" alt="image-20220721204130983" style="zoom:50%;" />

#### 页面分配策略

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721204234452.png" alt="image-20220721204234452" style="zoom:50%;" />

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721214224725.png" alt="image-20220721214224725" style="zoom:50%;" />

**驻留集：**指请求分页存储管理中给进程分配的物理块的集合。

在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。

若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少；驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小。

**固定分配：**操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，**驻留集大小不变**。

**可变分配：**先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，**驻留集大小可变**。

**局部置换：**发生缺页时只能选进程自己的物理块进行置换。

**全局置换：**可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。

**页面分配、置换策略：**

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721213248495.png" alt="image-20220721213248495" style="zoom:50%;" />

**何时调入页面：**

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721213442030.png" alt="image-20220721213442030" style="zoom:50%;" />

**从何处调入页面？**

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721213730567.png" alt="image-20220721213730567" style="zoom:50%;" />

**抖动（颠簸）现象：**

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721213841627.png" alt="image-20220721213841627" style="zoom:50%;" />

**工作集**：指在某段时间间隔里，进程实际访问页面的集合。

<img src="/assets/blog_res/2022-07-19-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220721214052979.png" alt="image-20220721214052979" style="zoom:50%;" />



























