<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="prefer-datetime-locale" content="Asia/Xi'an"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Essential C++" /><meta name="author" content="王家乐" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="第1章 C++编程基础" /><meta property="og:description" content="第1章 C++编程基础" /><link rel="canonical" href="https://jlwang1998.github.io/posts/Essential-C++/" /><meta property="og:url" content="https://jlwang1998.github.io/posts/Essential-C++/" /><meta property="og:site_name" content="jlwang1998" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-01-08T12:00:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Essential C++" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@王家乐" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"王家乐"},"dateModified":"2022-01-08T12:00:00+00:00","datePublished":"2022-01-08T12:00:00+00:00","description":"第1章 C++编程基础","headline":"Essential C++","mainEntityOfPage":{"@type":"WebPage","@id":"https://jlwang1998.github.io/posts/Essential-C++/"},"url":"https://jlwang1998.github.io/posts/Essential-C++/"}</script><title>Essential C++ | jlwang1998</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="jlwang1998"><meta name="application-name" content="jlwang1998"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/config/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">jlwang1998</a></div><div class="site-subtitle font-italic">机械转码学习笔记</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/jlwang1998" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['jlwang1998','163.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>Essential C++</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Essential C++</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1641643200" data-df="YYYY-MM-DD" data-toggle="tooltip" data-placement="bottom"> 2022-01-08 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> jlwang1998 </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="10337 字"> <em>57 分钟</em>阅读</span></div></div></div><div class="post-content"><h1 id="第1章-c编程基础">第1章 C++编程基础</h1><h2 id="命名空间namespace"><span class="mr-2">命名空间namespace</span><a href="#命名空间namespace" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h2 id="初始化语法构造函数语法"><span class="mr-2">初始化语法：构造函数语法</span><a href="#初始化语法构造函数语法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">num_trier</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></table></code></div></div><h2 id="模板类class-template必须在类名之后的尖括号内指定其元素类型"><span class="mr-2">模板类(class template)：必须在类名之后的尖括号内指定其元素类型</span><a href="#模板类class-template必须在类名之后的尖括号内指定其元素类型" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h2 id="pi指针的值pi指针的地址ival数值ival的地址"><span class="mr-2">*pi：指针的值；pi：指针的地址；&amp;ival：数值ival的地址</span><a href="#pi指针的值pi指针的地址ival数值ival的地址" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h2 id="读写文件"><span class="mr-2">读写文件：</span><a href="#读写文件" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="cp">#include</span><span class="cpf">&lt;fstream&gt;</span><span class="cp">
</span>
<span class="c1">//不希望丢弃原文件内容，用追加模式打开</span>
<span class="n">ofsream</span> <span class="nf">outfile</span><span class="p">(</span><span class="s">"seq_data.txt"</span><span class="p">,</span><span class="n">ios__base</span><span class="o">::</span><span class="n">app</span><span class="p">);</span>

<span class="c1">//读取文件</span>
<span class="n">ifstream</span> <span class="nf">infile</span><span class="p">(</span><span class="s">"seq_data.txt"</span><span class="p">);</span>

<span class="c1">//同时读写文件</span>
<span class="n">fstream</span> <span class="nf">iofile</span><span class="p">(</span><span class="s">"seq_data.txt"</span><span class="p">,</span><span class="n">ios__base</span><span class="o">::</span><span class="n">in</span><span class="o">||</span><span class="n">ios__base</span><span class="o">::</span><span class="n">app</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">iofile</span><span class="p">)</span>
    <span class="c1">//由于某种原因，文件无法打开</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="c1">//开始读取之前，将文件重新定位至起始处</span>
    <span class="n">iofile</span><span class="p">.</span><span class="n">seekg</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="include"><span class="mr-2">#include<iomanip>：</iomanip></span><a href="#include" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>io代表输入输出，manip是manipulator（操纵器）的缩写。</p><p>主要是对cin,cout之类的一些操纵运算子，比如setfill，setw，setbase，setprecision等等。它是I/O流控制头文件,就像C里面的格式化输出一样.以下是一些常见的控制函数的：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span> <span class="mi">3</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span> <span class="mi">3</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span> <span class="mi">3</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">100</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 
</pre></table></code></div></div><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="cp">#输出结果为
</span><span class="n">_</span> <span class="n">_1_10100</span> <span class="c1">//（默认是右对齐）当输出长度大于3时(&lt;&lt;1000)，setw(3)不起作用。</span>
</pre></table></code></div></div><p>▲setw(n)用法： 通俗地讲就是预设宽度</p><h1 id="第2章-面向对象的编程风格">第2章 面向对象的编程风格</h1><h2 id="传值和传址"><span class="mr-2">传值和传址</span><a href="#传值和传址" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>局部函数调用时，传值的话不会修改原参数的值，只会重新复制一个对象，称为”程序堆栈“。要想修改原参数，就需要用&amp;取址符号，船址。</p><h2 id="将参数声明为reference的理由"><span class="mr-2">将参数声明为reference的理由&amp;</span><a href="#将参数声明为reference的理由" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>希望得以直接对所传入的对象进行修改；降低复制大型对象的额外负担。</p><h2 id="reference指针"><span class="mr-2">reference&amp;、指针*</span><a href="#reference指针" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>pointer参数和reference参数的差异：pointer可能(也可能不)指向某个实际对象。当我们提领pointer时，一定要先确定其值为非0。而reference必定代表某个对象，所以不需要作此检查。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">ival</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ival</span><span class="p">;</span> <span class="c1">//表示pi为ival的地址，*pi为ival的值1024</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">rval</span> <span class="o">=</span> <span class="n">ival</span><span class="p">;</span> <span class="c1">//表示rval和ival为一个对象，两者地址相同</span>
</pre></table></code></div></div><pre><code class="language-C++">int *pi;
pi = new int(1024); //pi = 1024的地址，*pi为1024
</code></pre><pre><code class="language-C++">//将vector的参数声明为reference

#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;fstream&gt;
using namespace std;

void display(vector&lt;int&gt;&amp;vec)
{
	for(int i=0;i&lt;vec.size();i++)
	{
		cout&lt;&lt;vec[i]&lt;&lt;' ';
	}
	cout&lt;&lt;endl;
}
int main()
{
	int arr[8] = {8,34,3,13,1,21,5,2};
	vector&lt;int&gt;vec(arr,arr+8);
	cout&lt;&lt;"vector before sort: ";
	display(vec);

	return 0;
}
</code></pre><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="c1">//将vector以指针pointer传递</span>

<span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;fstream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">display</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span><span class="n">vec</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//在提领pointer时，要先确定其值非0</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">vec</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"display():the vector pointer is 0</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">vec</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="o">*</span><span class="n">vec</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="sc">' '</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">8</span><span class="p">,</span><span class="mi">34</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">};</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">vec</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="n">arr</span><span class="o">+</span><span class="mi">8</span><span class="p">);</span>
	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"vector before sort: "</span><span class="p">;</span>
	<span class="n">display</span><span class="p">(</span><span class="n">vec</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="作用域及范围"><span class="mr-2">作用域及范围</span><a href="#作用域及范围" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>对象如果在函数外部声明，则该对象的内存在main()开始执行之前就已经分配好，可以一直存在至程序结束。</p><p>内置类型的对象如果定义在file scope内，将被初始化为0；如果被定义于local scope之内，除非指定其初值，否则不会被初始化。</p><h2 id="动态内存管理"><span class="mr-2">动态内存管理</span><a href="#动态内存管理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="o">*</span><span class="n">pi</span><span class="p">;</span>
<span class="n">pi</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">int</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span>

<span class="kt">int</span> <span class="o">*</span><span class="n">pia</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">24</span><span class="p">]</span><span class="c1">//从heap中分配数组</span>

<span class="k">delete</span> <span class="n">pi</span><span class="p">;</span> <span class="c1">//释放pi所指的对象</span>
<span class="k">delete</span> <span class="p">[]</span><span class="n">pia</span><span class="p">;</span>
</pre></table></code></div></div><h2 id="提供默认参数值"><span class="mr-2">提供默认参数值</span><a href="#提供默认参数值" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>默认参数值规则：</p><p>(1) 解析操作由最右边开始进行，如果为某个参数提供了默认值，那么这一参数右侧的所有参数都必须也具有默认参数值。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c1">//错误：没有为vec提供默认值</span>
<span class="kt">void</span> <span class="nf">display</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="o">=</span><span class="n">cout</span><span class="p">,</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="n">vec</span><span class="p">);</span>
</pre></table></code></div></div><p>(2) 默认值只能指定一次</p><h2 id="声明inline函数"><span class="mr-2">声明inline函数</span><a href="#声明inline函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>将经常被调用、体积小的函数声明为inline，改善性能。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="nf">is_size_ok</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">max_size</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">size</span><span class="o">&lt;=</span><span class="mi">0</span><span class="o">||</span><span class="n">size</span><span class="o">&gt;</span><span class="n">max_size</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">cerr</span><span class="o">&lt;&lt;</span><span class="s">"invalid size</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span>
<span class="nf">fibon_seq</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">max_size</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">elems</span><span class="p">;</span>
	
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">is_size_ok</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">elems</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">&lt;</span><span class="n">size</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="o">||</span><span class="n">i</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">elems</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="n">elems</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">elems</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">elems</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">elems</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//返回Fibonacci数列中位置为pos的元素</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">fibon_elem</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">,</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">elem</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span><span class="n">pseq</span> <span class="o">=</span> <span class="n">fibon_seq</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">pseq</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">elem</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">elem</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">pseq</span><span class="p">)[</span><span class="n">pos</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="函数重载"><span class="mr-2">函数重载</span><a href="#函数重载" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>函数自动根据参数类型来调用函数。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"print a integer :"</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">float</span> <span class="n">a</span><span class="p">,</span><span class="kt">float</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"print a float :"</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
        <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
        <span class="n">add</span><span class="p">(</span><span class="mf">1.1</span><span class="p">,</span><span class="mf">2.1</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="定义并使用模板函数"><span class="mr-2">定义并使用模板函数</span><a href="#定义并使用模板函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>在函数重载时，定义函数时，每个函数非常相像，只有变量类型不同，使用模板函数解决。只需要定义一份函数内容。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre>#include&lt;iostream&gt;
using namespace std;

template&lt;typename elemType&gt;
void add(elemType a,elemType b)
{
        cout&lt;&lt;a+b&lt;&lt;endl;
}

int main()
{
		int a=1,b=2;
		float c=1.1,d=2.1;
        add(a,b);
        add(c,d);
        return 0;
}
</pre></table></code></div></div><h2 id="函数指针"><span class="mr-2">函数指针</span><a href="#函数指针" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">fibon_seq</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
<span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">lucas_seq</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
<span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">pell_seq</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
<span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">triang_seq</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
<span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">square_seq</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
<span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">pent_seq</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
</pre></table></code></div></div><p>为了获得该数组的第pos个数，我们采用函数指针，这样不需要提供6个不同的函数，只需定义一个。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c1">//返回Fibonacci数列中位置为pos的元素</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">fibon_elem</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">,</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">elem</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span><span class="n">pseq</span> <span class="o">=</span> <span class="n">fibon_seq</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>  <span class="c1">//(A)</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">pseq</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">elem</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">elem</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">pseq</span><span class="p">)[</span><span class="n">pos</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>只有A处不同，用函数指针代替。</p><p><strong>函数指针：</strong>必须指明其所指函数的返回类型及参数列表。本例中函数的返回类型是<code class="language-plaintext highlighter-rouge">const vector&lt;int&gt; *</code>，参数列表是<code class="language-plaintext highlighter-rouge">int</code>，函数指针的定义必须将*放在某个位置，表示这份定义所表现的是一个指针。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="p">(</span><span class="o">*</span><span class="n">seq_ptr</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span>
</pre></table></code></div></div><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c1">// 函数指针</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">fibon_elem</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">,</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">elem</span><span class="p">,</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="p">(</span><span class="o">*</span><span class="n">seq_ptr</span><span class="p">)(</span><span class="kt">int</span><span class="p">))</span>
<span class="p">{</span>
    <span class="c1">//检验指针是否指向某个函数</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">seq_ptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"Internal Error:seq_ptr is set to null!"</span><span class="p">;</span>
    <span class="p">}</span>
	<span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span><span class="n">pseq</span> <span class="o">=</span> <span class="n">seq_ptr</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">pseq</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">elem</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">elem</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">pseq</span><span class="p">)[</span><span class="n">pos</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c1">// 函数指针数组</span>
<span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="p">(</span><span class="o">*</span><span class="n">seq_array</span><span class="p">[])(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">fibon_seq</span><span class="p">,</span><span class="n">ns_lucas</span><span class="p">,</span><span class="n">ns_pent</span><span class="p">,</span>
    <span class="n">ns_triang</span><span class="p">,</span><span class="n">ns_square</span><span class="p">,</span><span class="n">ns_pent</span>
<span class="p">};</span>

<span class="c1">//循环调用</span>
<span class="kt">int</span> <span class="n">seq_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="n">next_seq</span><span class="o">==</span><span class="nb">true</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">seq_ptr</span> <span class="o">=</span> <span class="n">seq_array</span><span class="p">[</span><span class="o">++</span><span class="n">seq_index</span><span class="p">];</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="设定头文件"><span class="mr-2">设定头文件</span><a href="#设定头文件" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>函数定义只能有一份，inline函数例外，在每个调用点上，编译器都得取得其定义。因此，必须将inline函数定义在头文件中。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1">//将seq_array定义于file scope，需要在头文件声明</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">seq_cnt</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="c1">//const object喝inline一样，一出文件之外便不可见，因此不需要加extern</span>
<span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="p">(</span><span class="o">*</span><span class="n">seq_array</span><span class="p">[</span><span class="n">seq_cnt</span><span class="p">])(</span><span class="kt">int</span><span class="p">);</span><span class="c1">//错误写法，会被解读为定义</span>
<span class="k">extern</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="p">(</span><span class="o">*</span><span class="n">seq_array</span><span class="p">[</span><span class="n">seq_cnt</span><span class="p">])(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">//正确，声明</span>
</pre></table></code></div></div><p>包含头文件时，如果头文件喝包含此文件的程序代码文件位于同一个磁盘目录下，便使用双引号，否则使用尖括号。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="cp">#include</span><span class="cpf">"NumSeq.h"</span><span class="cp">
#include</span><span class="cpf">&lt;NumSeq.h&gt;</span><span class="cp">
</span></pre></table></code></div></div><h1 id="第3章-泛型编程风格">第3章 泛型编程风格</h1><p>STL由两种组件组成：</p><p>（1）容器：vector、list、set、map；</p><p>（2）泛型算法：find()、sort()、replace()、merge()</p><p>vector和list是顺序性容器，顺序性容器会依次维护第一个、第二个……直到最后一个元素。</p><p>map和set是关联性容器，关联性容器让我们快速查找容器中的元素值。map是key/value组合，key用于查找，value用来表示我们要储存或取出的数据。set仅含有key，可对其进行查询操作，来判断某值是否存在于其中。</p><h2 id="31-指针的算术运算"><span class="mr-2">3.1 指针的算术运算</span><a href="#31-指针的算术运算" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="array2和array2"><span class="mr-2">array[2]和*(array+2)</span><a href="#array2和array2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>array以第一个元素的指针传入函数，可以通过下标访问array中的每一个元素。如同此array是个对象(而非指针形式)一般。下标操作就是将array的起始地址加上索引值来产生某个元素的地址。然后对该地址进行提领（dereference）操作。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">array</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="o">*</span><span class="p">(</span><span class="n">array</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span><span class="c1">//结果一样</span>
</pre></table></code></div></div><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="c1">//无论数组元素的类型是什么，都可以访问数组中的每一个元素</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">elemType</span><span class="p">&gt;</span>
<span class="n">elemType</span><span class="o">*</span> <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">elemType</span> <span class="o">*</span><span class="n">first</span><span class="p">,</span><span class="k">const</span> <span class="n">elemType</span> <span class="o">*</span><span class="n">last</span><span class="p">,</span><span class="k">const</span> <span class="n">elemType</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">first</span><span class="o">||!</span><span class="n">last</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">//当first!=last，就把value拿来和first所指元素比较</span>
    <span class="k">for</span><span class="p">(;</span><span class="n">first</span><span class="o">!=</span><span class="n">last</span><span class="p">;</span><span class="o">++</span><span class="n">first</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="o">==</span><span class="n">value</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">frist</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="32-了解iterator泛型指针"><span class="mr-2">3.2 了解Iterator(泛型指针)</span><a href="#32-了解iterator泛型指针" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="c1">// iter被定义为一个iterator，指向一个vector，后者的元素类型为string。其初值指向svec的第一个元素。</span>
<span class="c1">// 双冒号::表示此iterator是位于string vector定义内的嵌套(nested)类型</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">svec</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span>
</pre></table></code></div></div><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c1">//用iterator取代下标运算符</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">elemType</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">display</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">elemType</span><span class="o">&gt;&amp;</span><span class="n">vec</span><span class="p">,</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">elemType</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">elemType</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">end_iter</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
    <span class="k">for</span><span class="p">(;</span><span class="n">iter</span><span class="o">!=</span><span class="n">end_iter</span><span class="p">;</span><span class="o">++</span><span class="n">iter</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">os</span><span class="o">&lt;&lt;*</span><span class="n">iter</span><span class="o">&lt;&lt;</span><span class="sc">' '</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">os</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="c1">// 重新实现find()，使得其支持一对指针或者一对指向某种容器的iterator</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">IteratorType</span><span class="p">,</span><span class="k">typename</span> <span class="nc">elemType</span><span class="p">&gt;</span>
<span class="n">IteratorType</span> <span class="nf">find</span><span class="p">(</span><span class="n">IteratorType</span> <span class="n">first</span><span class="p">,</span><span class="n">IteratorType</span> <span class="n">last</span><span class="p">,</span><span class="k">const</span> <span class="n">elemType</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span><span class="p">(;</span><span class="n">first</span><span class="o">!</span><span class="n">last</span><span class="p">;</span><span class="o">++</span><span class="n">first</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">value</span><span class="o">==*</span><span class="n">first</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">last</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//应用</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">asize</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">ia</span><span class="p">[</span><span class="n">asize</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">21</span><span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">ivec</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span><span class="n">ia</span><span class="o">+</span><span class="n">asize</span><span class="p">);</span>
<span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">ilist</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span><span class="n">ia</span><span class="o">+</span><span class="n">asize</span><span class="p">);</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">pia</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span><span class="n">ia</span><span class="o">+</span><span class="n">asize</span><span class="p">,</span><span class="mi">1024</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">pia</span><span class="o">!=</span><span class="n">ia</span><span class="o">+</span><span class="n">asize</span><span class="p">)</span>
    <span class="c1">//找到了......</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span><span class="p">;</span>
<span class="n">it</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">ivec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">ivec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="mi">1024</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">it</span><span class="o">!=</span><span class="n">ivec</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
    <span class="c1">//找到了......</span>
    
<span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span><span class="p">;</span>
<span class="n">iter</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">ilist</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">ilist</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="mi">1024</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">iter</span><span class="o">!=</span><span class="n">ilist</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
    <span class="c1">//找到了......</span>
</pre></table></code></div></div><h2 id="33-使用顺序性容器"><span class="mr-2">3.3 使用顺序性容器</span><a href="#33-使用顺序性容器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>vector、list、deque</p><p>deque：对于最前端元素的插入和删除，效率较高。</p><h3 id="容器的插入函数insert"><span class="mr-2">容器的插入函数insert()</span><a href="#容器的插入函数insert" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">,</span><span class="n">elemType</span> <span class="n">value</span><span class="p">);</span><span class="c1">//在position之前插入value</span>
<span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">,</span><span class="kt">int</span> <span class="n">count</span><span class="p">,</span><span class="n">elemType</span> <span class="n">value</span><span class="p">)</span><span class="err">；</span><span class="c1">//在position之前插入count个value</span>
<span class="kt">void</span> <span class="n">insert</span><span class="p">(</span><span class="n">iterator1</span> <span class="n">position</span><span class="p">,</span><span class="n">iterator2</span> <span class="n">first</span><span class="p">,</span><span class="n">iterator2</span> <span class="n">last</span><span class="p">);</span><span class="c1">//在position之前插入[firsy,last)所标识的各个元素</span>
</pre></table></code></div></div><h3 id="容器的删除操作erase"><span class="mr-2">容器的删除操作(erase)</span><a href="#容器的删除操作erase" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">);</span><span class="c1">//删除position指定的元素</span>
<span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">first</span><span class="p">,</span><span class="n">iterator</span> <span class="n">last</span><span class="p">);</span><span class="c1">//删除[first,last)范围内的元素</span>
</pre></table></code></div></div><h2 id="35-使用泛型算法"><span class="mr-2">3.5 使用泛型算法</span><a href="#35-使用泛型算法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="cp">#include</span><span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span></pre></table></code></div></div><p>四种泛型搜索算法：</p><p>（1）find()：用于搜索无序集合中是否存在某值；</p><p>（2）binary_search()：用于有序集合的搜素。如果搜索到目标，就返回true。binary_search()比find()更有效率；</p><p>（3）count()：返回数值相符的元素数目；</p><p>（4）search()：比对某个容器内是否存在某个子序列，如果存在，就返回一个iterator指向子序列的起始处，否则指向容器末尾。</p><h2 id="36-如何设计一个泛型算法"><span class="mr-2">3.6 如何设计一个泛型算法</span><a href="#36-如何设计一个泛型算法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="function-object"><span class="mr-2">Function Object</span><a href="#function-object" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">sort</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span> <span class="c1">//按降序排序</span>
</pre></table></code></div></div><h3 id="function-object-adapter"><span class="mr-2">Function Object Adapter</span><a href="#function-object-adapter" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>binder adapter(绑定适配器)会将function object的参数绑定至某个特定值。bind1st将指定值绑定至第一操作数，bind2nd将指定值绑定至第二操作数。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">filter_ver1</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="n">vec</span><span class="p">,</span><span class="kt">int</span> <span class="n">filter_val</span><span class="p">,</span><span class="n">less</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="n">lt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">nvec</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
    
    <span class="k">while</span><span class="p">((</span><span class="n">iter</span><span class="o">=</span><span class="n">find_if</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span><span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">bind2nd</span><span class="p">(</span><span class="n">lt</span><span class="p">,</span><span class="n">val</span><span class="p">)))</span><span class="o">!=</span><span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">nvec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">);</span>
        <span class="n">iter</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
	<span class="k">return</span> <span class="n">nvec</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="c1">// 消除filter()与vector元素类型，以及filter()与vector容器类型的依赖关系，使filter()更加泛型化</span>

<span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">InputIterator</span><span class="p">,</span><span class="k">typename</span> <span class="nc">OutputIterator</span><span class="p">,</span><span class="k">typename</span> <span class="nc">ElemType</span><span class="p">,</span><span class="k">typename</span> <span class="nc">Comp</span><span class="p">&gt;</span>
<span class="n">OutputIterator</span> <span class="nf">filter</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span><span class="n">InputIterator</span> <span class="n">last</span><span class="p">,</span><span class="n">OutputIterator</span> <span class="n">at</span><span class="p">,</span><span class="k">const</span> <span class="n">ElemType</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span><span class="n">Comp</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span><span class="p">((</span><span class="n">first</span><span class="o">=</span><span class="n">find_if</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="n">last</span><span class="p">,</span><span class="n">bind2nd</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span><span class="n">val</span><span class="p">)))</span><span class="o">!=</span><span class="n">last</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"found value: "</span><span class="o">&lt;&lt;*</span><span class="n">first</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
		<span class="o">*</span><span class="n">at</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">first</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">at</span><span class="p">;</span>	
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">elem_size</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ia</span><span class="p">[</span><span class="n">elem_size</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">12</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">43</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">};</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">ivec</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span><span class="n">ia</span><span class="o">+</span><span class="n">elem_size</span><span class="p">);</span>
	
	<span class="c1">//储存过滤结果</span>
	<span class="kt">int</span> <span class="n">ia2</span><span class="p">[</span><span class="n">elem_size</span><span class="p">];</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">ivec2</span><span class="p">(</span><span class="n">elem_size</span><span class="p">);</span>
	
	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"filtering integer array for values less than 8</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
	<span class="n">filter</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span><span class="n">ia</span><span class="o">+</span><span class="n">elem_size</span><span class="p">,</span><span class="n">ia2</span><span class="p">,</span><span class="n">elem_size</span><span class="p">,</span><span class="n">less</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>
	
	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"filtering integer vector for values greater than 8</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
	<span class="n">filter</span><span class="p">(</span><span class="n">ivec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">ivec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">ivec2</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">elem_size</span><span class="p">,</span><span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>
	
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">not1</code>可对<code class="language-plaintext highlighter-rouge">unary function object</code>的真伪值取反，not2可对<code class="language-plaintext highlighter-rouge">binary function object</code>的真伪值取反。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">while</span><span class="p">((</span><span class="n">iter</span><span class="o">=</span><span class="n">find_if</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span><span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">not1</span><span class="p">(</span><span class="n">bind2nd</span><span class="p">(</span><span class="n">lt</span><span class="p">,</span><span class="n">val</span><span class="p">)))</span><span class="o">!=</span><span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
</pre></table></code></div></div><h2 id="37-使用map"><span class="mr-2">3.7 使用map</span><a href="#37-使用map" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="cp">#include</span><span class="cpf">&lt;map&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">words</span><span class="p">;</span>
<span class="c1">//循环打印所有单词出现的次数</span>
<span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="k">for</span><span class="p">(;</span><span class="n">it</span><span class="o">!=</span><span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="o">++</span><span class="n">it</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"keys: "</span><span class="o">&lt;&lt;</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span>
        <span class="o">&lt;&lt;</span><span class="s">"value: "</span><span class="o">&lt;&lt;</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//查询map内是否有某个key</span>
<span class="c1">//利用find()函数,如果存在key，find()函数返回key/value形成的pair；不存在返回end()</span>
<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span><span class="p">;</span>
<span class="n">it</span> <span class="o">=</span> <span class="n">words</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">"vermeer"</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">it</span><span class="o">!=</span><span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">seond</span><span class="p">;</span>

<span class="c1">//利用count()函数，返回某特定项在map内的个数</span>
<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">string</span> <span class="nf">search_word</span><span class="p">(</span><span class="s">"vermeer"</span><span class="p">);</span>

<span class="k">if</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">search_word</span><span class="p">))</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">word</span><span class="p">[</span><span class="n">search_word</span><span class="p">];</span>
</pre></table></code></div></div><h2 id="38-使用set"><span class="mr-2">3.8 使用Set</span><a href="#38-使用set" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Set由一群key组合而成，对于任何key值只能存储一份。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="cp">#include</span><span class="cpf">&lt;set&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="c1">//定义一个用来记录“排除字眼”的set</span>
<span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="n">word_exclusion</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">tword</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">word_exclusion</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">tward</span><span class="p">))</span>
        <span class="k">continue</span><span class="p">;</span><span class="c1">//不执行后续语句，进入下一轮while循环    </span>
    <span class="n">words</span><span class="p">[</span><span class="n">tward</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//为set插入单一元素</span>
<span class="n">iset</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">ival</span><span class="p">);</span>
<span class="c1">//为set插入某个范围的元素</span>
<span class="n">iset</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</pre></table></code></div></div><h2 id="39-如何使用iterator-inserter"><span class="mr-2">3.9 如何使用Iterator Inserter</span><a href="#39-如何使用iterator-inserter" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>将源端容器中每一个符合条件的元素一一幅值至目的端容器时，目的端容器必须足够大。以前的方法是将目的端容器大小设置为与源端容器大小相同，这样子会占用较大内存。</p><p>C++标准库提供3个insertion adapter：</p><p>（1）<code class="language-plaintext highlighter-rouge">back_inserter()</code>：以容器的<code class="language-plaintext highlighter-rouge">push_back()</code>取代赋值运算符。传入的参数就是容器本身。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">result_vec</span><span class="p">;</span>
<span class="n">unique_copy</span><span class="p">(</span><span class="n">ivec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">ivec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">result_vec</span><span class="p">));</span>
</pre></table></code></div></div><p>（2）<code class="language-plaintext highlighter-rouge">inserter()</code>：以容器的<code class="language-plaintext highlighter-rouge">insert()</code>函数取代<code class="language-plaintext highlighter-rouge">assignment</code>运算符。接收参数为<code class="language-plaintext highlighter-rouge">容器和iterator</code>，iterator指向插入操作的起点。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="n">svec_res</span><span class="p">;</span>
<span class="n">unique_copy</span><span class="p">(</span><span class="n">svec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">svec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">inserter</span><span class="p">(</span><span class="n">svec_res</span><span class="p">,</span><span class="n">svec_res</span><span class="p">.</span><span class="n">end</span><span class="p">()));</span>
</pre></table></code></div></div><p>（3）<code class="language-plaintext highlighter-rouge">front_inserter()</code>：以容器的<code class="language-plaintext highlighter-rouge">push_front()</code>函数取代<code class="language-plaintext highlighter-rouge">assignment</code>运算符。只适用于<code class="language-plaintext highlighter-rouge">list</code>和<code class="language-plaintext highlighter-rouge">deque</code></p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">ilist_clone</span><span class="p">;</span>
<span class="n">copy</span><span class="p">(</span><span class="n">ilist</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">ilist</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">front_inserter</span><span class="p">(</span><span class="n">ilist_clone</span><span class="p">));</span>
</pre></table></code></div></div><p>需要包含头文件：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="cp">#include</span><span class="cpf">&lt;iterator&gt;</span><span class="cp">
</span></pre></table></code></div></div><p>将3.6节的main函数改写为：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">elem_size</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ia</span><span class="p">[</span><span class="n">elem_size</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">12</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">43</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">};</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">ivec</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span><span class="n">ia</span><span class="o">+</span><span class="n">elem_size</span><span class="p">);</span>
	
	<span class="c1">//储存过滤结果</span>
	<span class="kt">int</span> <span class="n">ia2</span><span class="p">[</span><span class="n">elem_size</span><span class="p">];</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">ivec2</span><span class="p">(</span><span class="n">elem_size</span><span class="p">);</span>
	
	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"filtering integer array for values less than 8</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
	<span class="n">filter</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span><span class="n">ia</span><span class="o">+</span><span class="n">elem_size</span><span class="p">,</span><span class="n">ia2</span><span class="p">,</span><span class="n">elem_size</span><span class="p">,</span><span class="n">less</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span><span class="c1">//以上inserter不能用于array</span>
	
	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"filtering integer vector for values greater than 8</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
	<span class="n">filter</span><span class="p">(</span><span class="n">ivec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">ivec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">ivec2</span><span class="p">),</span><span class="n">elem_size</span><span class="p">,</span><span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>
	
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="310-使用iostream-iterator"><span class="mr-2">3.10 使用iostream Iterator</span><a href="#310-使用iostream-iterator" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;iterator&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;fstream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="cm">/*
	//从文件读取
	ifstream in_file("input_file.txt");
	ofstream out_file("out_file.txt");
	
	if(!in_file||!out_file)
	{
		cerr&lt;&lt;"!!unable to open the necessary files.\n";
		return -1;
	}
	istream_iterator&lt;string&gt;is(infile);//first iterator
	istream_iterator&lt;string&gt;eof; //在定义istream_iterator时，不指定对象，就代表为last iterator
	
	vector&lt;string&gt;text;
	copy(is,eof,back_inserter(text));//泛型算法copy()
	
	ostream_iterator&lt;string&gt;os(out_file," "); //第一个参数为字符串输出位置，第二个参数为各个元素被输出时的分隔符
	copy(text.begin(),text.end(),os); //copy()函数将text每一个元素一一写到os所表示的ostream上
	*/</span>
	<span class="c1">//从标准输入输出设备读取</span>
	<span class="n">istream_iterator</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="n">is</span><span class="p">(</span><span class="n">cin</span><span class="p">);</span><span class="c1">//first iterator</span>
	<span class="n">istream_iterator</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="n">eof</span><span class="p">;</span> <span class="c1">//在定义istream_iterator时，不指定对象，就代表为last iterator</span>
	
	<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="n">text</span><span class="p">;</span>
	<span class="n">copy</span><span class="p">(</span><span class="n">is</span><span class="p">,</span><span class="n">eof</span><span class="p">,</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">text</span><span class="p">));</span><span class="c1">//泛型算法copy()</span>
	
	<span class="n">sort</span><span class="p">(</span><span class="n">text</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">text</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
	
	<span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="n">os</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span><span class="s">" "</span><span class="p">);</span> <span class="c1">//第一个参数为字符串输出位置，第二个参数为各个元素被输出时的分隔符</span>
	<span class="n">copy</span><span class="p">(</span><span class="n">text</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">text</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">os</span><span class="p">);</span> <span class="c1">//copy()函数将text每一个元素一一写到os所表示的ostream上</span>
	
	
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="泛型算法partition"><span class="mr-2">泛型算法partition()</span><a href="#泛型算法partition" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>std::partition会将区间[first,last)中的元素重新排列，满足判断条件pred的元素会被放在区间的前段，不满足pred的元素会被放在区间的后段。可以用来区分奇偶。该算法不能保证元素的初始相对位置，如果需要保证初始相对位置，应该使用stable_partition.</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="cp">#include</span><span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">bool</span> <span class="nf">cmp</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&lt;=</span><span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v1</span> <span class="o">=</span> <span class="p">{</span><span class="s">"fjskf"</span><span class="p">,</span> <span class="s">"fjslfjksl"</span><span class="p">,</span> <span class="s">"fjsklfk"</span><span class="p">,</span> <span class="s">"f"</span><span class="p">,</span> <span class="s">"fdds"</span><span class="p">,</span> <span class="s">"fjs"</span><span class="p">,</span> <span class="s">"fjslf"</span><span class="p">};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v2</span> <span class="o">=</span> <span class="p">{</span><span class="s">"fjskf"</span><span class="p">,</span> <span class="s">"fjslfjksl"</span><span class="p">,</span> <span class="s">"fjsklfk"</span><span class="p">,</span> <span class="s">"f"</span><span class="p">,</span> <span class="s">"fdds"</span><span class="p">,</span> <span class="s">"fjs"</span><span class="p">,</span> <span class="s">"fjslf"</span><span class="p">};</span>
    <span class="k">auto</span> <span class="n">x1</span><span class="o">=</span><span class="n">partition</span><span class="p">(</span><span class="n">v1</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">v1</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">cmp</span><span class="p">());</span><span class="c1">//将满足条件的放在前面，不满足条件的放在后面，不保证稳定。</span>
    <span class="k">auto</span> <span class="n">x2</span><span class="o">=</span><span class="n">stable_partition</span><span class="p">(</span><span class="n">v2</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">v2</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">cmp</span><span class="p">());</span><span class="c1">//将满足条件的放在前面，不满足条件的放在后面，保证稳定。</span>
<span class="p">}</span>
</pre></table></code></div></div><h1 id="第4章-基于对象的编程风格">第4章 基于对象的编程风格</h1><p>class由两部分组成：公开的(public)操作函数、私有的(private)实现细节。</p><h2 id="41-如何实现一个class"><span class="mr-2">4.1 如何实现一个class</span><a href="#41-如何实现一个class" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Class声明：<code class="language-plaintext highlighter-rouge">class Stack;</code></p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="c1">//class 定义</span>
<span class="k">class</span> <span class="nc">Stack</span><span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">push</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">pop</span><span class="p">(</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">elem</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">peek</span><span class="p">(</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">elem</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">)</span><span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">empty</span><span class="p">();</span>
    <span class="kt">bool</span> <span class="n">full</span><span class="p">();</span>
    
    <span class="c1">//size()定义与class本身中</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">(){</span><span class="k">return</span> <span class="n">_stack</span><span class="p">.</span><span class="n">size</span><span class="p">();}</span>
<span class="nl">private:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="n">_stack</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">//在class主体之外定义成员函数</span>
<span class="c1">//::类作用域解析运算符</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">Stack</span><span class="o">::</span><span class="n">empty</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">_stack</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Stack</span><span class="o">::</span><span class="n">pop</span><span class="p">(</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">elem</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">empty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">elem</span> <span class="o">=</span> <span class="n">_stack</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
    <span class="n">_stack</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">bool</span> <span class="n">Stack</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">elem</span><span class="p">)</span><span class="k">const</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">_stack</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">_stack</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">elem</span><span class="p">)</span><span class="o">!=</span><span class="n">_stack</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="c1">//:;全局作用域，如果不加，会递归到自己的find()</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="42-什么是构造函数和析构函数"><span class="mr-2">4.2 什么是构造函数和析构函数</span><a href="#42-什么是构造函数和析构函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="构造函数constructor"><span class="mr-2">构造函数(Constructor)</span><a href="#构造函数constructor" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>用来初始化data member，函数名称必须和类名相同，可以被重载。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Triangular</span><span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">//一组重载的constructor</span>
    <span class="n">Triangular</span><span class="p">();</span><span class="c1">//默认</span>
    <span class="n">Triangular</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
    <span class="n">Triangular</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span><span class="kt">int</span> <span class="n">beg_pos</span><span class="p">);</span>
    
<span class="nl">private:</span>
    <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_length</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_beg_pos</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_next</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">//构造函数初始化,法一</span>
<span class="n">Triangular</span><span class="o">::</span><span class="n">Triangular</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span><span class="kt">int</span> <span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">_length</span> <span class="o">=</span> <span class="n">len</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">?</span><span class="n">len</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">_beg_pos</span> <span class="o">=</span> <span class="n">bp</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">?</span><span class="n">bp</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">_next</span> <span class="o">=</span> <span class="n">_bet_pos</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//法二：成员初始化列表,主要用于将参数传给member class object</span>
<span class="n">Triangular</span><span class="o">::</span><span class="n">Triangular</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span><span class="kt">int</span> <span class="n">bp</span><span class="p">)</span>
    <span class="o">:</span><span class="n">_name</span><span class="p">(</span><span class="s">"Triangular"</span><span class="p">)</span>   <span class="c1">//将Triangular传给_name</span>
<span class="p">{</span>
    <span class="n">_length</span> <span class="o">=</span> <span class="n">len</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">?</span><span class="n">len</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">_beg_pos</span> <span class="o">=</span> <span class="n">bp</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">?</span><span class="n">bp</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">_next</span> <span class="o">=</span> <span class="n">_bet_pos</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="析构函数destructor"><span class="mr-2">析构函数(destructor)</span><a href="#析构函数destructor" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>用于释放在constructor中或对象生命周期中分配的资源。名称为：类名加上’~’的前缀，不能被重载。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Matrix</span><span class="p">{</span>
    <span class="nl">public:</span>
    <span class="n">Matrix</span><span class="p">(</span><span class="kt">int</span> <span class="n">row</span><span class="p">,</span><span class="kt">int</span> <span class="n">col</span><span class="p">)</span>
        <span class="o">:</span><span class="n">_row</span><span class="p">(</span><span class="n">row</span><span class="p">),</span><span class="n">_col</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
    <span class="p">{</span>
		<span class="n">_pmat</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">(</span><span class="n">row</span><span class="o">*</span><span class="n">col</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">Matrix</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">delete</span> <span class="p">[]</span><span class="n">_pmat</span><span class="p">;</span> <span class="c1">//释放内存</span>
    <span class="p">}</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">_row</span><span class="p">,</span><span class="n">_col</span><span class="p">;</span>
    <span class="kt">double</span><span class="o">*</span> <span class="n">_pmat</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="成员逐一初始化"><span class="mr-2">成员逐一初始化</span><a href="#成员逐一初始化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">Triangular</span> <span class="nf">tri1</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
<span class="n">Triangular</span> <span class="n">tri2</span> <span class="o">=</span> <span class="n">tri1</span><span class="p">;</span> <span class="c1">//_length、_beg_pos、_next会依次从tri1复制到tri2.</span>
</pre></table></code></div></div><p>成员逐一初始化可能导致已经释放内存的数组重新进行释放内存操作（对指针操作时），会报错。为防止这个问题，通过提供一个<code class="language-plaintext highlighter-rouge">copy constructor</code>。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="nl">Matrix:</span><span class="n">Matrix</span><span class="p">(</span><span class="k">const</span> <span class="n">Matrix</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
    <span class="o">:</span><span class="n">_row</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">_row</span><span class="p">),</span><span class="n">_col</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">_col</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//对rhs._pmat所指的数组产生一份完全副本</span>
    <span class="kt">int</span> <span class="n">elem_cnt</span> <span class="o">=</span> <span class="n">_row</span><span class="o">*</span><span class="n">_col</span><span class="p">;</span>
    <span class="n">_pmat</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">elem_cnt</span><span class="p">];</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">ix</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">ix</span><span class="o">&lt;</span><span class="n">elem_cnt</span><span class="p">;</span><span class="o">++</span><span class="n">ix</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_pmat</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">_pmat</span><span class="p">[</span><span class="n">ix</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="43-何谓mutable可变和const不变"><span class="mr-2">4.3 何谓mutable（可变）和const（不变）</span><a href="#43-何谓mutable可变和const不变" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="k">const</span> <span class="n">Triangular</span> <span class="o">&amp;</span><span class="n">train</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">beg_pos</span> <span class="o">=</span> <span class="n">train</span><span class="p">.</span><span class="n">beg_pos</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">train</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">ix</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">ix</span><span class="o">&lt;</span><span class="n">length</span><span class="p">;</span><span class="o">++</span><span class="n">ix</span><span class="p">)</span>
        <span class="n">sum</span><span class="o">+=</span><span class="n">train</span><span class="p">.</span><span class="n">elem</span><span class="p">(</span><span class="n">beg_pos</span><span class="o">+</span><span class="n">ix</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>train为<code class="language-plaintext highlighter-rouge">const reference</code>参数，train不能被修改。需要在调用train的相关函数时，加上const。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">length</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span><span class="k">return</span> <span class="n">_length</span><span class="p">;}</span>
</pre></table></code></div></div><p>当想要修改与类状态无关的数据成员，加上关键字<code class="language-plaintext highlighter-rouge">mutable</code>。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Triangular</span><span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">next</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span><span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">next_reset</span><span class="p">()</span><span class="k">const</span> <span class="p">{</span><span class="n">_next</span> <span class="o">=</span> <span class="n">_beg_pos</span><span class="o">-</span><span class="mi">1</span><span class="p">;}</span>
    
<span class="nl">private:</span>
    <span class="k">mutable</span> <span class="kt">int</span> <span class="n">_next</span><span class="p">;</span>  <span class="c1">//修改_next不会被视为改变了class object的状态</span>
    <span class="kt">int</span> <span class="n">_beg_pos</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_length</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="44-什么是this指针"><span class="mr-2">4.4 什么是this指针</span><a href="#44-什么是this指针" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>this指针：在成员函数内指向其调用者(一个对象)。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="n">Triangular</span><span class="o">&amp;</span> <span class="n">Triangular</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="k">const</span> <span class="n">Triangular</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="o">!=</span><span class="n">rhs</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_length</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">_length</span><span class="p">;</span>
        <span class="n">_beg_pos</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">_beg_pos</span><span class="p">;</span>
        <span class="n">_next</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">_beg_pos</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="45-静态类成员"><span class="mr-2">4.5 静态类成员</span><a href="#45-静态类成员" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="static-data-member"><span class="mr-2">static data member</span><a href="#static-data-member" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>表示唯一的、可共享的member，只有唯一的一份实体，类似全局对象。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Triangular</span><span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">//...</span>
<span class="nl">private:</span>
    <span class="k">static</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">_elems</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">//在程序代码文件中进行定义</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">Triangular</span><span class="o">::</span><span class="n">_elems</span><span class="p">;</span>
</pre></table></code></div></div><h3 id="static-member-function"><span class="mr-2">static member function</span><a href="#static-member-function" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>一般情况下，成员函数必须通过某个类的对象进行调用（实例化对象，通过对象来调用成员函数）。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="n">Triangular</span><span class="o">::</span><span class="n">is_elem</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">_elems</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">||</span><span class="n">_elems</span><span class="p">[</span><span class="n">_elems</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="n">value</span><span class="p">)</span>
        <span class="n">gen_elems_to_value</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">found_it</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">end_it</span> <span class="o">=</span> <span class="n">_elems</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
    <span class="n">found_it</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">_elems</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">end_it</span><span class="p">,</span><span class="n">value</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">found_it</span><span class="o">!=</span><span class="n">end_it</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">is_elem()</code>并未访问任何<code class="language-plaintext highlighter-rouge">non_static data member</code>，就无需通过类的对象进行调用。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">if</span><span class="p">(</span><span class="n">Triangular</span><span class="o">::</span><span class="n">is_elem</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span> <span class="c1">//这样调用即可</span>
</pre></table></code></div></div><h2 id="46-打造一个iterator-class"><span class="mr-2">4.6 打造一个Iterator Class</span><a href="#46-打造一个iterator-class" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>为Iterator Class定义!-、*、++等运算符</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Triangular_iterator</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Triangular_iterator</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span><span class="o">:</span><span class="n">_index</span><span class="p">(</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">){};</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">Triangular_iterator</span><span class="o">&amp;</span><span class="p">)</span><span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">Triangular_iterator</span><span class="o">&amp;</span><span class="p">)</span><span class="k">const</span><span class="p">;</span>
    <span class="kt">int</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span><span class="k">const</span><span class="p">;</span>
    <span class="n">Triangular_iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">();</span> <span class="c1">//前置++</span>
    <span class="n">Triangular_iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">//后置++</span>
<span class="nl">private:</span>
    <span class="kt">void</span> <span class="n">check_integrity</span><span class="p">()</span><span class="k">const</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_index</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">Triangular_iterator</span><span class="o">::</span><span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">Triangular_iterator</span> <span class="o">&amp;</span><span class="n">ths</span><span class="p">)</span><span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">_index</span><span class="o">==</span><span class="n">rhs</span><span class="p">.</span><span class="n">_index</span><span class="p">;</span>  <span class="c1">//判断两个Triangular_iterator的_index是否相等</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">int</span> <span class="n">Triangular_iterator</span><span class="o">::</span><span class="k">operator</span><span class="o">*</span><span class="p">()</span><span class="k">const</span>
<span class="p">{</span>
    <span class="n">check_integrity</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">Triangular</span><span class="o">::</span><span class="n">_elems</span><span class="p">[</span><span class="n">_index</span><span class="p">];</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">void</span> <span class="n">Triangular_iterator</span> <span class="nf">check_integrity</span><span class="p">()</span><span class="k">const</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">_index</span><span class="o">&gt;=</span><span class="n">Triangular</span><span class="o">::</span><span class="n">_max_elems</span><span class="p">)</span>
        <span class="k">throw</span> <span class="n">iterator_overflow</span><span class="p">();</span>
    
    <span class="k">if</span><span class="p">(</span><span class="n">_index</span><span class="o">&gt;=</span><span class="n">Triangular</span><span class="o">::</span><span class="n">_elems</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
        <span class="n">Triangular</span><span class="o">::</span><span class="n">gen_elements</span><span class="p">(</span><span class="n">_index</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="err">}</span>

<span class="c1">//前置++</span>
<span class="kr">inline</span> <span class="n">Triangular_iterator</span><span class="o">&amp;</span> <span class="n">Triangular_iterator</span><span class="o">::</span><span class="k">operator</span><span class="o">++</span><span class="p">()</span>
<span class="p">{</span>
    <span class="o">++</span><span class="n">_index</span><span class="p">;</span>
    <span class="n">check_integrity</span><span class="p">();</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//后置++</span>
 <span class="kr">inline</span> <span class="n">Triangular_iterator</span><span class="o">&amp;</span> <span class="n">Triangular_iterator</span><span class="o">::</span><span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Triangular_iterator</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> 
    <span class="o">++</span><span class="n">_index</span><span class="p">;</span>
    <span class="n">check_integrity</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">tmp</span><span class="p">;;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="47-友元friend"><span class="mr-2">4.7 友元friend</span><a href="#47-友元friend" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>为了访问private member，可以在某个函数原型前加上关键字friend。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">//将重载函数声明为某个class的friend</span>
<span class="k">class</span> <span class="nc">Triangular</span><span class="p">{</span>
    <span class="k">friend</span> <span class="kt">int</span> <span class="n">Triangular_iterator</span><span class="o">::</span><span class="k">operator</span><span class="o">*</span><span class="p">();</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="n">Triangular_iterator</span><span class="o">::</span><span class="n">check_integrity</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="48-实现一个function-object"><span class="mr-2">4.8 实现一个function object</span><a href="#48-实现一个function-object" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>function object是一种“提供有function call运算符”的class。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre><td class="rouge-code"><pre><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">LessThan</span><span class="p">{</span>
<span class="nl">public:</span>
		<span class="n">LessThan</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span><span class="o">:</span><span class="n">_val</span><span class="p">(</span><span class="n">val</span><span class="p">){}</span>
		<span class="kt">int</span> <span class="n">comp_val</span><span class="p">()</span><span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">_val</span><span class="p">;}</span> <span class="c1">//基值的读取</span>
		<span class="kt">void</span> <span class="n">comp_val</span><span class="p">(</span><span class="kt">int</span> <span class="n">nval</span><span class="p">){</span><span class="n">_val</span><span class="o">=</span><span class="n">nval</span><span class="p">;}</span> <span class="c1">//基值的写入</span>
		<span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">_value</span><span class="p">)</span><span class="k">const</span><span class="p">;</span>
<span class="nl">private:</span>
			<span class="kt">int</span> <span class="n">_val</span><span class="p">;</span>
<span class="p">};</span>

<span class="kr">inline</span> <span class="kt">bool</span> <span class="n">LessThan</span><span class="o">::</span><span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span><span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">value</span><span class="o">&lt;</span><span class="n">_val</span><span class="p">;}</span>

<span class="kt">int</span> <span class="nf">count_less_than</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="n">vec</span><span class="p">,</span><span class="kt">int</span> <span class="n">comp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LessThan</span> <span class="n">It</span><span class="p">(</span><span class="n">comp</span><span class="p">);</span>
	
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">ix</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">ix</span><span class="o">&lt;</span><span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">ix</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">It</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">ix</span><span class="p">]))</span>
		<span class="o">++</span><span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">print_less_than</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="n">vec</span><span class="p">,</span><span class="kt">int</span> <span class="n">comp</span><span class="p">,</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="o">=</span><span class="n">cout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LessThan</span> <span class="n">It</span><span class="p">(</span><span class="n">comp</span><span class="p">);</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">it_end</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
	
	<span class="n">os</span><span class="o">&lt;&lt;</span><span class="s">"elements less than "</span><span class="o">&lt;&lt;</span><span class="n">It</span><span class="p">.</span><span class="n">comp_val</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
	<span class="k">while</span><span class="p">((</span><span class="n">iter</span><span class="o">=</span><span class="n">find_if</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span><span class="n">it_end</span><span class="p">,</span><span class="n">It</span><span class="p">))</span><span class="o">!=</span><span class="n">it_end</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">os</span><span class="o">&lt;&lt;*</span><span class="n">iter</span><span class="o">&lt;&lt;</span><span class="sc">' '</span><span class="p">;</span>
		<span class="o">++</span><span class="n">iter</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ia</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">17</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">44</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">45</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span>
	<span class="mi">23</span><span class="p">,</span><span class="mi">67</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">27</span><span class="p">,</span><span class="mi">55</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">16</span><span class="p">};</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">vec</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span><span class="n">ia</span><span class="o">+</span><span class="mi">16</span><span class="p">);</span>
	
	<span class="kt">int</span> <span class="n">comp_val</span><span class="o">=</span><span class="mi">20</span><span class="p">;</span>
	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"Number of elements less than "</span><span class="o">&lt;&lt;</span><span class="n">comp_val</span><span class="o">&lt;&lt;</span><span class="s">" are "</span><span class="o">&lt;&lt;</span><span class="n">count_less_than</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span><span class="n">comp_val</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
	<span class="n">print_less_than</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span><span class="n">comp_val</span><span class="p">);</span>
		
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="410-重载iostream运算符"><span class="mr-2">4.10 重载iostream运算符</span><a href="#410-重载iostream运算符" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="c1">//重载output运算符</span>
<span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span><span class="k">const</span> <span class="n">Triangular</span> <span class="o">&amp;</span><span class="n">ths</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">os</span><span class="o">&lt;&lt;</span><span class="s">"("</span><span class="o">&lt;&lt;</span><span class="n">rhs</span><span class="p">.</span><span class="n">beg_pos</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="s">","</span><span class="o">&lt;&lt;</span><span class="n">rhs</span><span class="p">.</span><span class="n">length</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="s">")"</span><span class="p">;</span>
    <span class="n">rhs</span><span class="p">.</span><span class="n">display</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">length</span><span class="p">(),</span><span class="n">rhs</span><span class="p">.</span><span class="n">beg_pos</span><span class="p">(),</span><span class="n">os</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//重载input运算符</span>
<span class="n">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">istream</span> <span class="o">&amp;</span><span class="n">is</span><span class="p">,</span><span class="n">Triangular</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">ch1</span><span class="p">,</span><span class="n">ch2</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">bp</span><span class="p">,</span><span class="n">len</span><span class="p">;</span>
    <span class="c1">//假设输入为(3,6) 6 10 15 21 28 36</span>
    <span class="c1">//那么ch1=='('，bp==3，ch2==','，len==6</span>
    <span class="n">is</span><span class="o">&gt;&gt;</span><span class="n">ch1</span><span class="o">&gt;&gt;</span><span class="n">bp</span><span class="o">&gt;&gt;</span><span class="n">ch2</span><span class="o">&gt;&gt;</span><span class="n">len</span><span class="p">;</span>
    
    <span class="n">rhs</span><span class="p">.</span><span class="n">beg_pos</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
    <span class="n">rhs</span><span class="p">.</span><span class="n">length</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
    <span class="n">rhs</span><span class="p">.</span><span class="n">next_reset</span><span class="p">();</span>
    
    <span class="k">return</span> <span class="n">is</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c1">//调用output运算符</span>
<span class="n">Triangular</span> <span class="nf">tri</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">tri</span><span class="o">&lt;&lt;</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

<span class="c1">//输出结果</span>
<span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span> <span class="mi">6</span> <span class="mi">10</span> <span class="mi">15</span> <span class="mi">21</span> <span class="mi">28</span> <span class="mi">36</span>
</pre></table></code></div></div><h2 id="411-指针指向class-member-function"><span class="mr-2">4.11 指针，指向Class Member Function</span><a href="#411-指针指向class-member-function" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>将PtrType声明为一个指针，指向num_sequence的member function</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="nf">void</span><span class="p">(</span><span class="n">num_sequence</span><span class="o">::*</span><span class="n">PtrType</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
<span class="n">PtrType</span> <span class="n">pm</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> 
</pre></table></code></div></div><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">num_sequence</span><span class="p">{</span>
<span class="nl">public:</span>
	<span class="k">typedef</span> <span class="kt">void</span><span class="p">(</span><span class="n">num_sequence</span><span class="o">::*</span><span class="n">PtrType</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
    
    <span class="c1">//_pmf可指向下列任何一个函数</span>
    <span class="kt">void</span> <span class="n">fibonacci</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">pell</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">lucas</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">triangular</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">sequare</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">pentagonal</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="nl">private:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">_elem</span><span class="p">;</span> <span class="c1">//指向目前所用的vector</span>
    <span class="n">PtrType</span> <span class="n">_pmf</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">num_seq</span><span class="o">=</span><span class="mi">7</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">PtrType</span> <span class="n">func_tbl</span><span class="p">[</span><span class="n">num_seq</span><span class="p">];</span>
    <span class="k">static</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="n">seq</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>定义一个指针，并指向成员函数<code class="language-plaintext highlighter-rouge">fibonacci()</code></p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">PtrType</span> <span class="n">pm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">num_sequence</span><span class="o">::</span><span class="n">fibonacci</span><span class="p">;</span>
</pre></table></code></div></div><p>对<code class="language-plaintext highlighter-rouge">static data member</code>定义</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>const int num_sequence::num_seq;
vector&lt;vector&lt;int&gt; &gt;num_sequence::seq(num_seq);

num_sequence::PtrType num_sequence::func_tbl[num_seq] = 
{
	0,
	&amp;num_sequence::fibonacci,
	&amp;num_sequence::pell,
	&amp;num_sequence::lucas,
	&amp;num_sequence::triangular,
	&amp;num_sequence::sequare,
	&amp;num_sequence::pentagonal
}
</pre></table></code></div></div><h2 id="习题"><span class="mr-2">习题</span><a href="#习题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="enum枚举"><span class="mr-2">enum枚举</span><a href="#enum枚举" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">enum</span> <span class="n">Roster</span> <span class="p">{</span><span class="n">Tom</span><span class="p">,</span> <span class="n">Sharon</span><span class="p">,</span> <span class="n">Bill</span><span class="p">,</span> <span class="n">Teresa</span><span class="p">,</span> <span class="n">John</span><span class="p">};</span>
</pre></table></code></div></div><p>该语句将创建一个名为 Roster 的数据类型。因为单词 enum 是 C++ 关键字，所以它必须小写，值得注意的是，数据类型本身的名字是以大写字母开头的。虽然这并非必须，但是绝大多数程序员都会釆用首字母大写的形式。</p><p>和 Roster 数据类型关联的命名整数常量被称为枚举量，Roster 数据类型的变量可能只是关联到这些枚举量的值之一，但它们的值是什么呢？</p><p>默认情况下，编译器设置第一个枚举量为 0，下一个为 1，以此类推。在上述示例中，Tom 的值将是 0，Sharon 的值为 1，等等。最后一个枚举量 John 的值为 4。</p><h3 id="itoa"><span class="mr-2">itoa()</span><a href="#itoa" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">itoa</span><span class="p">()</span><span class="o">:</span><span class="kt">char</span> <span class="o">*</span><span class="nf">itoa</span><span class="p">(</span> <span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">,</span><span class="kt">int</span> <span class="n">radix</span><span class="p">);</span>
</pre></table></code></div></div><p>value：欲转换的数据。 string：目标字符串的地址。 radix：转换后的进制数，可以是10进制、16进制等，范围必须在 2-36。</p><p>功能：将整数value 转换成字符串存入string 指向的内存空间 ,radix 为转换时所用基数(保存到字符串中的数据的进制基数)。 返回值：函数返回一个指向 str，无错误返回。</p><h1 id="第5章-面向对象编程风格">第5章 面向对象编程风格</h1><h2 id="51-面向对象编程概念"><span class="mr-2">5.1 面向对象编程概念</span><a href="#51-面向对象编程概念" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>特征：</strong>继承、多态、动态绑定。</p><p><strong>多态：</strong>让基类的pointer或reference得以十分透明地指向任何一个派生类地对象。</p><p><strong>动态绑定：</strong>每次loan_check_in()执行时，仅能在执行过程中依据mat所指地实际对象来决定调用哪一个check_in()。找出实际被调用地究竟是哪一个派生类地check_in()函数这一解析操作会延时到运行时进行。</p><h2 id="52-漫游面向对象编程地思维"><span class="mr-2">5.2 漫游：面向对象编程地思维</span><a href="#52-漫游面向对象编程地思维" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>默认情况下，成员函数的解析在编译时静态地进行，若要令其在运行时动态进行，需要在它的声明前加上关键字<code class="language-plaintext highlighter-rouge">virtual</code>。静态成员函数无法被声明为虚函数。</p><p>被声明为<code class="language-plaintext highlighter-rouge">protected</code>的所有成员都可以被派生类直接访问，除了派生类之外，都不能直接访问protected成员。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
</pre><td class="rouge-code"><pre><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">LibMat</span><span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">LibMat</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"LibMat::LibMat() default constructor!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">virtual</span> <span class="o">~</span><span class="n">LibMat</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"LibMat::~LibMat() destructor!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">print</span><span class="p">()</span><span class="k">const</span>
	<span class="p">{</span>
		<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"LibMat::print()--I am a LibMat object!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Book</span><span class="o">:</span><span class="k">public</span> <span class="n">LibMat</span><span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">Book</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">title</span><span class="p">,</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">author</span><span class="p">)</span><span class="o">:</span><span class="n">_title</span><span class="p">(</span><span class="n">title</span><span class="p">),</span><span class="n">_author</span><span class="p">(</span><span class="n">author</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"Book::Book("</span><span class="o">&lt;&lt;</span><span class="n">_title</span><span class="o">&lt;&lt;</span><span class="s">","</span><span class="o">&lt;&lt;</span><span class="n">_author</span><span class="o">&lt;&lt;</span><span class="s">") constructor</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">virtual</span> <span class="o">~</span><span class="n">Book</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"Book::~Book()destructor!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">print</span><span class="p">()</span><span class="k">const</span>
	<span class="p">{</span>
		<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"Book::print()--I am a Book object!</span><span class="se">\n</span><span class="s">"</span>
			<span class="o">&lt;&lt;</span><span class="s">"My title is: "</span><span class="o">&lt;&lt;</span><span class="n">_title</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span>
			<span class="o">&lt;&lt;</span><span class="s">"My author is: "</span><span class="o">&lt;&lt;</span><span class="n">_author</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">title</span><span class="p">()</span><span class="k">const</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">_title</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">author</span><span class="p">()</span><span class="k">const</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">_author</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">protected:</span>
	<span class="n">string</span> <span class="n">_title</span><span class="p">;</span>
	<span class="n">string</span> <span class="n">_author</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">AudioBook</span><span class="o">:</span><span class="k">public</span> <span class="n">Book</span><span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">AudioBook</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">title</span><span class="p">,</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">author</span><span class="p">,</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">narrator</span><span class="p">)</span><span class="o">:</span><span class="n">Book</span><span class="p">(</span><span class="n">title</span><span class="p">,</span><span class="n">author</span><span class="p">),</span><span class="n">_narrator</span><span class="p">(</span><span class="n">narrator</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"AudioBook::AudioBook( "</span><span class="o">&lt;&lt;</span><span class="n">_title</span><span class="o">&lt;&lt;</span><span class="s">", "</span><span class="o">&lt;&lt;</span><span class="n">_author</span><span class="o">&lt;&lt;</span><span class="s">", "</span><span class="o">&lt;&lt;</span><span class="n">_narrator</span><span class="o">&lt;&lt;</span><span class="s">") constructor</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">~</span><span class="n">AudioBook</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"AudioBook::~AudioBook()destructor</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">print</span><span class="p">()</span><span class="k">const</span>
	<span class="p">{</span>
		<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"AudioBook::print()--I am a AudioBook object!</span><span class="se">\n</span><span class="s">"</span>
			<span class="o">&lt;&lt;</span><span class="s">"My title is:"</span> <span class="o">&lt;&lt;</span><span class="n">_title</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span>
			<span class="o">&lt;&lt;</span><span class="s">"My author is: "</span><span class="o">&lt;&lt;</span><span class="n">_author</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span>
			<span class="o">&lt;&lt;</span><span class="s">"My narrator is: "</span><span class="o">&lt;&lt;</span><span class="n">_narrator</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">narrator</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">_narrator</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">protected:</span>
	<span class="n">string</span> <span class="n">_narrator</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">const</span> <span class="n">LibMat</span> <span class="o">&amp;</span><span class="n">mat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"in global print():about to print mat.print()</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
	<span class="n">mat</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="c1">//	cout&lt;&lt;"\n"&lt;&lt;"Creating a LibMat object to print()\n";</span>
<span class="c1">//	LibMat libmat;</span>
<span class="c1">//	print(libmat);</span>
	<span class="n">AudioBook</span> <span class="n">ab</span><span class="p">(</span><span class="s">"Mason and Dixon"</span><span class="p">,</span><span class="s">"Thomax Pynchon"</span><span class="p">,</span><span class="s">"Edwin Leonard"</span><span class="p">);</span>	
	<span class="n">print</span><span class="p">(</span><span class="n">ab</span><span class="p">);</span>	
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="54-定义一个抽象的基类"><span class="mr-2">5.4 定义一个抽象的基类</span><a href="#54-定义一个抽象的基类" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>设计抽象类的步骤：</strong></p><p>（1）找到所有子类共通的操作行为；</p><p>（2）找到哪些操作行为与类型相关，也就是说，有哪些行为必须根据不同的派生类而有不同的实现方式。这些操作行为应该成为整个类继承体系中的虚函数。</p><p>（3）找到每个操作行为的访问层级：public、private、protected</p><p><strong>注意：</strong></p><p>（1）每个虚函数。要么得有其定义，要么可设为<code class="language-plaintext highlighter-rouge">纯虚函数</code>。如果对于该类而言，这个虚函数并无实际意义，那么令他为纯虚函数。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">virtual</span> <span class="kt">int</span> <span class="n">elem</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">)</span><span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></table></code></div></div><p>（2）根据一般规则，凡基类定义有一个或多个虚函数，应将其析构函数声明为<code class="language-plaintext highlighter-rouge">virtual</code>。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nf">num_sequence</span><span class="p">(){</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">num_sequence</span><span class="p">(){};</span>
<span class="p">}</span><span class="err">；</span>
</pre></table></code></div></div><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">num_sequence</span><span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">num_sequence</span><span class="p">(){};</span>
    
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">elem</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">)</span><span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">what_am_i</span><span class="p">()</span><span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">max_elems</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="n">_max_elems</span><span class="p">;}</span>
    <span class="k">virtual</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="n">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="o">=</span><span class="n">cout</span><span class="p">)</span><span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">gen_elems</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">)</span><span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">check_integrity</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">,</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span><span class="k">const</span><span class="p">;</span>
    
    <span class="k">const</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">_max_elems</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">bool</span> <span class="n">num_sequence</span><span class="o">::</span><span class="n">check_integrity</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">,</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span><span class="k">const</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pos</span><span class="o">&lt;=</span><span class="mi">0</span><span class="o">||</span><span class="n">pos</span><span class="o">&gt;</span><span class="n">_max_elems</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cerr</span><span class="o">&lt;&lt;</span><span class="s">"!!invalid position: "</span><span class="o">&lt;&lt;</span><span class="n">pos</span><span class="o">&lt;&lt;</span><span class="s">"Cannot honor request</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pos</span><span class="o">&gt;</span><span class="n">size</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">gen_elems</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span><span class="k">const</span> <span class="n">num_sequence</span> <span class="o">&amp;</span><span class="n">ns</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">ns</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="55-定义一个派生类"><span class="mr-2">5.5 定义一个派生类</span><a href="#55-定义一个派生类" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>派生类由两部分组成：</strong></p><p>（1）基类构成的子对象，由基类的<code class="language-plaintext highlighter-rouge">non-static data member</code>组成；</p><p>（2）派生类的部分（由派生类的<code class="language-plaintext highlighter-rouge">non-static data member</code>组成）。</p><p><strong>注意：</strong></p><p>（1）基类的public member在派生类中同样是public，开放给派生类的用户使用；基类中的protected member在派生类中是protected，只能给后续派生类使用，无法给目前这个派生类使用；</p><p>（2）当派生类有某个member与其基类的member同名时，便会遮掩住基类的那份member。如果要在派生类内使用继承来的那份member，必须利用class scope运算符加以限定。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Fibonacci</span><span class="o">:</span><span class="k">public</span> <span class="n">num_sequence</span><span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Fibonacci</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="kt">int</span> <span class="n">beg_pos</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="n">_length</span><span class="p">(</span><span class="n">len</span><span class="p">),</span><span class="n">_beg_pos</span><span class="p">(</span><span class="n">beg_pos</span><span class="p">){}</span>
    
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">elem</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">)</span><span class="k">const</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">what_am_i</span><span class="p">()</span><span class="k">const</span><span class="p">{</span><span class="k">return</span> <span class="s">"Fibonacci"</span><span class="p">;}</span>
    <span class="k">virtual</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="n">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="o">=</span><span class="n">cout</span><span class="p">)</span><span class="k">const</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">length</span><span class="p">()</span><span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">_length</span><span class="p">;}</span>
    <span class="kt">int</span> <span class="n">beg_pos</span><span class="p">()</span><span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">_beg_pos</span><span class="p">;}</span>
<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">gen_elems</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">)</span><span class="k">const</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">_length</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_beg_pos</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">_elems</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">Fibonacci</span><span class="o">::</span><span class="n">elem</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">)</span><span class="k">const</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">check_integrity</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="n">_elems</span><span class="p">.</span><span class="n">size</span><span class="p">()))</span> <span class="c1">//调用的是继承来的check_integrity()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pos</span><span class="o">&gt;</span><span class="n">_elems</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">Fibonacci</span><span class="o">::</span><span class="n">gen_elems</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span><span class="c1">//通过class scope运算符，告诉编译器，调用的是Fibonacci派生类的gen_elems()</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">_elems</span><span class="p">[</span><span class="n">pos</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Fibonacci</span><span class="o">::</span><span class="n">gen_elems</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">)</span><span class="k">const</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">_elems</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">_elems</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">_elems</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">_elems</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&lt;=</span><span class="n">pos</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">ix</span> <span class="o">=</span> <span class="n">_elems</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">n_2</span> <span class="o">=</span> <span class="n">_elems</span><span class="p">[</span><span class="n">ix</span><span class="o">-</span><span class="mi">2</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">n_1</span> <span class="o">=</span> <span class="n">_elems</span><span class="p">[</span><span class="n">ix</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
        
        <span class="k">for</span><span class="p">(;</span><span class="n">ix</span><span class="o">&lt;=</span><span class="n">pos</span><span class="p">;</span><span class="o">++</span><span class="n">ix</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">elem</span> <span class="o">=</span> <span class="n">n_2</span><span class="o">+</span><span class="n">n_1</span><span class="p">;</span>
            <span class="n">_elems</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">elem</span><span class="p">);</span>
            <span class="n">n_2</span><span class="o">=</span><span class="n">n_1</span><span class="p">;</span><span class="n">n_1</span><span class="o">=</span><span class="n">elem</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">ostream</span><span class="o">&amp;</span> <span class="n">Fibonacci</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">)</span><span class="k">const</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">elem_pos</span> <span class="o">=</span> <span class="n">_beg_pos</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">end_pos</span> <span class="o">=</span> <span class="n">elem_pos</span> <span class="o">+</span> <span class="n">_length</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">end_pos</span><span class="o">&gt;</span><span class="n">_elems</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">Fibonacci</span><span class="o">::</span><span class="n">gen_elems</span><span class="p">(</span><span class="n">end_pos</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">while</span><span class="p">(</span><span class="n">elem_pos</span><span class="o">&lt;</span><span class="n">end_pos</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">os</span><span class="o">&lt;&lt;</span><span class="n">_elems</span><span class="p">[</span><span class="n">elem_pos</span><span class="o">++</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="sc">' '</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Fibonacci</span> <span class="n">fib</span><span class="p">;</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"fib:beginning at element 1 for 1 element: "</span><span class="o">&lt;&lt;</span><span class="n">fib</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    
    <span class="n">Fibonacci</span> <span class="n">fib2</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"fib2:beginning at element 1 for 16 element: "</span><span class="o">&lt;&lt;</span><span class="n">fib2</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    
    <span class="n">Fibonacci</span> <span class="n">fib3</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">12</span><span class="p">);</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"fib3:beginning at element 12 for 8 element: "</span><span class="o">&lt;&lt;</span><span class="n">fib3</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="57-基类应该多么抽象"><span class="mr-2">5.7 基类应该多么抽象</span><a href="#57-基类应该多么抽象" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>在当前的设计下，抽象基类只提供接口，并未提供任何实现。当需要加入新的数列类时，比较繁琐。提出新的设计方式：将所以派生类共有的实现内容剥离出来，移至基类内。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">num_sequence</span><span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">num_sequence</span><span class="p">(){};</span>
    
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">elem</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">)</span><span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">what_am_i</span><span class="p">()</span><span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">elem</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">)</span><span class="k">const</span><span class="p">;</span>
    <span class="n">ostream</span><span class="o">&amp;</span> <span class="n">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="o">=</span><span class="n">cout</span><span class="p">)</span><span class="k">const</span><span class="p">;</span>
    
    <span class="kt">int</span> <span class="n">length</span><span class="p">()</span><span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">_length</span><span class="p">;}</span>
    <span class="kt">int</span> <span class="n">beg_pos</span><span class="p">()</span><span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">_beg_pos</span><span class="p">;}</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">max_elems</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="mi">64</span><span class="p">;}</span>
<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">gen_elems</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">)</span><span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">check_integrity</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">,</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span><span class="k">const</span><span class="p">;</span>
    <span class="c1">//num_sequence是抽象基类，无法为它定义任何对象，所以声明为protected</span>
    <span class="n">num_sequence</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span><span class="kt">int</span> <span class="n">bp</span><span class="p">,</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="n">re</span><span class="p">)</span><span class="o">:</span><span class="n">_length</span><span class="p">(</span><span class="n">len</span><span class="p">),</span><span class="n">_beg_pos</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span><span class="n">_relems</span><span class="p">(</span><span class="n">re</span><span class="p">){}</span>
    
    <span class="kt">int</span> <span class="n">_length</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_beg_pos</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">_relems</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Fibonacci</span><span class="o">:</span><span class="k">public</span> <span class="n">num_sequence</span><span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Fibonacci</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="kt">int</span> <span class="n">beg_pos</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">what_am_i</span><span class="p">()</span><span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="s">"Fibonacci"</span><span class="p">;</span>
    <span class="p">}</span>
    
<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">gen_elems</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">)</span><span class="k">const</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">_elems</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="59-在派生类中定义一个虚函数"><span class="mr-2">5.9 在派生类中定义一个虚函数</span><a href="#59-在派生类中定义一个虚函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>当定义派生类时，必须决定，究竟要将基类中的虚函数覆盖掉，还是原封不动地加以继承。如果我们继承了纯虚函数，那么派生类也将被视为抽象类，无法为它定义任何对象。</p><p>如果要覆盖掉基类提供地虚函数，派生类定义地函数原型必须完全符合基类所声明的函数原型，包括：参数列表、返回类型、常量性(const-ness)。</p><h3 id="虚函数的静态解析"><span class="mr-2">虚函数的静态解析</span><a href="#虚函数的静态解析" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>派生类虚函数机制不会出现预期行为：</p><p>（1）基类的constructor和destructor内</p><p>当我们构造派生类对象时，基类的constructor会先被调用，如果在基类的constructor中调用某个虚函数，此时调用的就是基类中的虚函数。</p><p>（2）当我们使用的是基类的对象，而非基类对象的pointer或reference时</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="n">LibMat</span> <span class="n">object</span><span class="p">,</span><span class="k">const</span> <span class="n">LibMat</span> <span class="o">*</span><span class="n">pointer</span><span class="p">,</span><span class="k">const</span> <span class="n">LibMat</span> <span class="o">&amp;</span><span class="n">reference</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">object</span><span class="p">.</span><span class="n">print</span><span class="p">();</span><span class="c1">//此时调用的是LibMat::print()</span>
    
    <span class="c1">//会通过虚函数机制进行解析</span>
    <span class="n">pointer</span><span class="o">-&gt;</span><span class="n">print</span><span class="p">();</span>
    <span class="n">reference</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="510-运行时的类型鉴定机制"><span class="mr-2">5.10 运行时的类型鉴定机制</span><a href="#510-运行时的类型鉴定机制" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>每一个类中都有一份<code class="language-plaintext highlighter-rouge">what_am_i()</code>函数，为了简化，利用运行时的类型鉴定机制。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="cp">#include</span><span class="cpf">&lt;typeinfo&gt;</span><span class="cp">
</span>
<span class="kr">inline</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">num_sequence</span><span class="o">::</span><span class="n">what_am_i</span><span class="p">()</span><span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">typeid</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">).</span><span class="n">name</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">if</span><span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="o">*</span><span class="n">ps</span><span class="p">)</span><span class="o">==</span><span class="k">typeid</span><span class="p">(</span><span class="n">Fibonacci</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">Fibonacci</span> <span class="o">*</span><span class="n">pf</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Fibonacci</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">ps</span><span class="p">);</span><span class="c1">//经过static_cast运算符转换指针变为派生类指针</span>
    <span class="n">pf</span><span class="o">-&gt;</span><span class="n">gen_elems</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//static_cast有个潜在危险，就是编译器无法确定转换类指针从基类到派生类是不是转换对了</span>
<span class="c1">//使用dynamic_cast运算符提供有条件的转换，可避免这个危险</span>

<span class="k">if</span><span class="p">(</span><span class="n">Fibonacci</span> <span class="o">*</span><span class="n">pf</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Fibonacci</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">os</span><span class="p">))</span>
    <span class="n">pf</span><span class="o">-&gt;</span><span class="n">gen_elems</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>
</pre></table></code></div></div><h1 id="第6章-以template进行编程">第6章 以template进行编程</h1><p><strong>二叉树的遍历：</strong></p><p>（1）前序遍历：被遍历的节点本身先被打印，然后打印左子树内容，最后打印右子树内容；</p><p>（2）中序遍历：先打印左子树，然后是节点本身，最后是右子树；</p><p>（3）后续遍历：先打印左子树，再打印右子树，最后是节点本身。</p><h2 id="62-class-template的定义"><span class="mr-2">6.2 Class Template的定义</span><a href="#62-class-template的定义" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">elemType</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">BinaryTree</span><span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">BinaryTree</span><span class="p">();</span>
    <span class="n">BinaryTree</span><span class="p">(</span><span class="k">const</span> <span class="n">BinaryTree</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="o">~</span><span class="n">BinaryTree</span><span class="p">();</span>
    <span class="n">BinaryTree</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">BinaryTree</span><span class="o">&amp;</span><span class="p">);</span>
    
    <span class="kt">bool</span> <span class="n">empty</span><span class="p">(){</span><span class="k">return</span> <span class="n">_root</span><span class="o">==</span><span class="mi">0</span><span class="p">};</span>
    <span class="kt">void</span> <span class="n">clear</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">_root</span><span class="p">)</span>
            <span class="n">clear</span><span class="p">(</span><span class="n">_root</span><span class="p">);</span>
        <span class="n">_root</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="nl">private:</span>
    <span class="kt">void</span> <span class="n">clear</span><span class="p">(</span><span class="n">BTnode</span><span class="o">&lt;</span><span class="n">elemType</span><span class="o">&gt;*</span><span class="p">)</span>
    <span class="n">BTnode</span><span class="o">&lt;</span><span class="n">elemType</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">_root</span><span class="p">;</span>
    <span class="c1">//将src所指子树复制到tar所指子树</span>
    <span class="kt">void</span> <span class="n">copy</span><span class="p">(</span><span class="n">BTnode</span><span class="o">&lt;</span><span class="n">elemType</span><span class="o">&gt;*</span><span class="n">tar</span><span class="p">,</span><span class="n">BTnode</span><span class="o">&lt;</span><span class="n">elemType</span><span class="o">&gt;*</span><span class="n">src</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">elemType</span><span class="p">&gt;</span>
<span class="kr">inline</span> <span class="n">BinaryTree</span><span class="o">&lt;</span><span class="n">elemType</span><span class="o">&gt;::</span><span class="n">BinaryTree</span><span class="p">()</span><span class="o">:</span><span class="n">_root</span><span class="p">(</span><span class="mi">0</span><span class="p">){}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">elemType</span><span class="p">&gt;</span>
<span class="kr">inline</span> <span class="n">BinaryTree</span><span class="o">&lt;</span><span class="n">elemType</span><span class="o">&gt;::</span><span class="n">BinaryTree</span><span class="p">(</span><span class="k">const</span> <span class="n">BinaryTree</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">copy</span><span class="p">(</span><span class="n">_root</span><span class="p">,</span><span class="n">rhs</span><span class="p">.</span><span class="n">_root</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">elemType</span><span class="p">&gt;</span>
<span class="kr">inline</span> <span class="n">BinaryTree</span><span class="o">&lt;</span><span class="n">elemType</span><span class="o">&gt;::~</span><span class="n">BinaryTree</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">clear</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">elemType</span><span class="p">&gt;</span>
<span class="kr">inline</span> <span class="n">BinaryTree</span><span class="o">&lt;</span><span class="n">elemType</span><span class="o">&gt;&amp;</span> <span class="n">BinaryTree</span><span class="o">&lt;</span><span class="n">elemType</span><span class="o">&gt;::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">BinaryTree</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="o">!=&amp;</span><span class="n">rhs</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">clear</span><span class="p">();</span>
        <span class="n">copy</span><span class="p">(</span><span class="n">_root</span><span class="p">,</span><span class="n">rhs</span><span class="p">.</span><span class="n">_root</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="63-template类型参数的处理"><span class="mr-2">6.3 Template类型参数的处理</span><a href="#63-template类型参数的处理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>将所有的template类型参数视为”class类型”，应使用下列的初始化方法。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">valType</span><span class="p">&gt;</span>
<span class="kr">inline</span> <span class="n">BTnode</span><span class="o">&lt;</span><span class="n">valType</span><span class="o">&gt;::</span><span class="n">BTnode</span><span class="p">(</span><span class="k">const</span> <span class="n">valType</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span><span class="o">:</span><span class="n">_val</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="c1">//将valType视为class类型</span>
<span class="p">{</span>
    <span class="n">_cnt</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">_lchild</span> <span class="o">=</span> <span class="n">_rchild</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="64-实现一个class-template"><span class="mr-2">6.4 实现一个Class Template</span><a href="#64-实现一个class-template" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>插入某个新值：</strong></p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">elemType</span><span class="p">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">BinaryTree</span><span class="o">&lt;</span><span class="n">elemType</span><span class="o">&gt;::</span><span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">elemType</span> <span class="o">&amp;</span><span class="n">elem</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">_root</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BTnode</span><span class="o">&lt;</span><span class="n">elemType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">elem</span><span class="p">);</span><span class="c1">//如果根节点设为设定，就分配一块新的BTnode需要的内存空间</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">_root</span><span class="o">-&gt;</span><span class="n">insert_value</span><span class="p">(</span><span class="n">elem</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//小于根节点的值放在左子树，大于的放在右子树，每个数值在数中只出现一次，使用cnt记录该节点插入的次数</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">valType</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">BTnode</span><span class="o">&lt;</span><span class="n">valType</span><span class="o">&gt;::</span><span class="n">insert_value</span><span class="p">(</span><span class="k">const</span> <span class="n">valType</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">val</span><span class="o">==</span><span class="n">_val</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_cnt</span><span class="o">++</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">val</span><span class="o">&lt;</span><span class="n">_val</span><span class="p">)</span><span class="c1">//小于根节点，放在左子树</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">_lchild</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_lchild</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BTnode</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">_lchild</span><span class="o">-&gt;</span><span class="n">insert_value</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="c1">//大于根节点，放在右子树</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">_rchild</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_rchild</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BTnode</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">_rchild</span><span class="o">-&gt;</span><span class="n">insert_value</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p><strong>移除某值：</strong>以节点的右子节点取代节点本身，然后搬移左子节点，使它成为右子节点的左子树的叶节点。如果此刻无右子节点，那么就以左子节点取代节点本身。将根节点的移除操作以特例处理。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">elemType</span><span class="p">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">BinaryTree</span><span class="o">&lt;</span><span class="n">elemType</span><span class="o">&gt;::</span><span class="n">remove</span><span class="p">(</span><span class="k">const</span> <span class="n">elemType</span> <span class="o">&amp;</span><span class="n">elem</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">_root</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">_root</span><span class="o">-&gt;</span><span class="n">val</span><span class="o">==</span><span class="n">elem</span><span class="p">)</span>
            <span class="n">remove_root</span><span class="p">();</span>
        <span class="k">else</span>
            <span class="n">_root</span><span class="o">-&gt;</span><span class="n">remove_value</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span><span class="n">_root</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//搬移左子节点</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">elemType</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">BTnode</span><span class="o">&lt;</span><span class="n">valType</span><span class="o">&gt;::</span><span class="n">lchild_leaf</span><span class="p">(</span><span class="n">BTnode</span> <span class="o">*</span><span class="n">leaf</span><span class="p">,</span><span class="n">BTnode</span> <span class="o">*</span><span class="n">subtree</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="n">subtree</span><span class="o">-&gt;</span><span class="n">_lchild</span><span class="p">)</span>
        <span class="n">subtree</span> <span class="o">=</span> <span class="n">subtree</span><span class="o">-&gt;</span><span class="n">_lchild</span><span class="p">;</span>
    <span class="n">subtree</span><span class="o">-&gt;</span><span class="n">_lchild</span> <span class="o">=</span> <span class="n">leaf</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//根节点的移除</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">elemType</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">BinaryTree</span><span class="o">&lt;</span><span class="n">elemType</span><span class="o">&gt;::</span><span class="n">remove_root</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">_root</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="n">BTnode</span><span class="o">&lt;</span><span class="n">elemType</span><span class="o">&gt;*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">_root</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">_root</span><span class="o">-&gt;</span><span class="n">_rchild</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//右子节点设为根节点</span>
        <span class="n">_root</span> <span class="o">=</span> <span class="n">_root</span><span class="o">-&gt;</span><span class="n">_rchild</span><span class="p">;</span>
        <span class="c1">//将左子节点搬移到右子节点的左子树底部</span>
        <span class="k">if</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">_lchild</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">BTnode</span><span class="o">&lt;</span><span class="n">elemType</span><span class="o">&gt;*</span><span class="n">lc</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">_lchild</span><span class="p">;</span><span class="c1">//原左子节点</span>
            <span class="n">BTnode</span><span class="o">&lt;</span><span class="n">elemType</span><span class="o">&gt;*</span><span class="n">newlc</span> <span class="o">=</span> <span class="n">_root</span><span class="o">-&gt;</span><span class="n">_lchild</span><span class="p">;</span><span class="c1">//原右子树的左子节点</span>
            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">newlc</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">//没有左子节点，</span>
                <span class="n">_root</span><span class="o">-&gt;</span><span class="n">_lchild</span> <span class="o">=</span> <span class="n">lc</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">BTnode</span><span class="o">&lt;</span><span class="n">elemType</span><span class="o">&gt;::</span><span class="n">lchild_leaf</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span><span class="n">newlc</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="n">_root</span> <span class="o">=</span> <span class="n">_root</span><span class="o">-&gt;</span><span class="n">_lchild</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//其他节点的移除,remove_value()拥有两个参数：将被删除的值以及一个指向目前关注的节点的父节点的指针</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">valType</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">BTnode</span><span class="o">&lt;</span><span class="n">valType</span><span class="o">&gt;::</span><span class="n">remove_value</span><span class="p">(</span><span class="k">const</span> <span class="n">valType</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span><span class="n">BTnode</span> <span class="o">*&amp;</span><span class="n">prev</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">val</span><span class="o">&lt;</span><span class="n">_val</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">_lchild</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="n">_lchild</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="n">_lchild</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">val</span><span class="o">&gt;</span><span class="n">_val</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">_rchild</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="n">_rchild</span><span class="o">-&gt;</span><span class="n">remove_value</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="n">_rchild</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">//找到了，重置此树，并删除这一节点</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">_rchild</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">_rchild</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">_lchild</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">_lchild</span><span class="p">)</span>
                    <span class="n">prev</span><span class="o">-&gt;</span><span class="n">_lchild</span> <span class="o">=</span> <span class="n">_lchild</span><span class="p">;</span>
                <span class="k">else</span>
                    <span class="n">BTnode</span><span class="o">&lt;</span><span class="n">valType</span><span class="o">&gt;::</span><span class="n">lchild_leaf</span><span class="p">(</span><span class="n">_lchild</span><span class="p">,</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">_lchild</span><span class="p">;</span>
        <span class="k">delete</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>   
<span class="p">}</span>
</pre></table></code></div></div><p><strong>移除整颗二叉树</strong></p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">elemType</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">BinaryTree</span><span class="o">&lt;</span><span class="n">elemType</span><span class="o">&gt;::</span><span class="n">clear</span><span class="p">(</span><span class="n">BTnode</span><span class="o">&lt;</span><span class="n">elemType</span><span class="o">&gt;*</span><span class="n">pt</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">clear</span><span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">_lchild</span><span class="p">);</span>
        <span class="n">clear</span><span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">_rchild</span><span class="p">);</span>
        <span class="k">delete</span> <span class="n">pt</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p><strong>遍历算法</strong></p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="c1">//前序遍历</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">valType</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">BTnode</span><span class="o">&lt;</span><span class="n">valType</span><span class="o">&gt;::</span><span class="n">preorder</span><span class="p">(</span><span class="n">BTnode</span> <span class="o">*</span><span class="n">pt</span><span class="p">,</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">)</span><span class="k">const</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">display_val</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span><span class="n">os</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">_lchild</span><span class="p">)</span> <span class="n">preorder</span><span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">_lchild</span><span class="p">,</span><span class="n">os</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">_rchild</span><span class="p">)</span> <span class="n">preorder</span><span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">_rchild</span><span class="p">,</span><span class="n">os</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//中序遍历</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">valType</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">BTnode</span><span class="o">&lt;</span><span class="n">valType</span><span class="o">&gt;::</span><span class="n">inorder</span><span class="p">(</span><span class="n">BTnode</span> <span class="o">*</span><span class="n">pt</span><span class="p">,</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">)</span><span class="k">const</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">_lchild</span><span class="p">)</span> <span class="n">inorder</span><span class="p">(</span><span class="n">_lchild</span><span class="p">,</span><span class="n">os</span><span class="p">);</span>
        <span class="n">display_val</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span><span class="n">os</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">_rchild</span><span class="p">)</span> <span class="n">inorder</span><span class="p">(</span><span class="n">_rchild</span><span class="p">,</span><span class="n">os</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//后序遍历</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">valType</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">BTnode</span><span class="o">&lt;</span><span class="n">valType</span><span class="o">&gt;::</span><span class="n">postorder</span><span class="p">(</span><span class="n">BTnode</span> <span class="o">*</span><span class="n">pt</span><span class="p">,</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">)</span><span class="k">const</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">_lchild</span><span class="p">)</span> <span class="n">postorder</span><span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">_lchild</span><span class="p">,</span><span class="n">os</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">_rchild</span><span class="p">)</span> <span class="n">postorder</span><span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">_rchild</span><span class="p">,</span><span class="n">os</span><span class="p">);</span>
        <span class="n">display_val</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span><span class="n">os</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="65-一个以function-template完成的output运算符"><span class="mr-2">6.5 一个以Function Template完成的Output运算符</span><a href="#65-一个以function-template完成的output运算符" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">valType</span><span class="p">&gt;</span>
<span class="kr">inline</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span><span class="k">const</span> <span class="n">BinaryTree</span><span class="o">&lt;</span><span class="n">elemType</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">bt</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">os</span><span class="o">&lt;&lt;</span><span class="s">"Tree: "</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">bt</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="66-常量表达式与默认参数值"><span class="mr-2">6.6 常量表达式与默认参数值</span><a href="#66-常量表达式与默认参数值" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>可以用常量表达式作为template的参数，将“对象所含的元素个数”参数化。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span><span class="kt">int</span> <span class="n">beg_pos</span><span class="o">=</span><span class="mi">1</span><span class="p">&gt;</span>

<span class="n">Fibonacci</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="n">fib</span><span class="p">;</span>
</pre></table></code></div></div><p>全局作用域内的函数及对象，其地址也是一种常量表达式，因此也可以被拿来表达这一形式的参数。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">)(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">,</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">&gt;</span><span class="o">&amp;</span><span class="n">seq</span><span class="p">)</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">numeric_sequence</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">numeric_sequence</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span><span class="kt">int</span> <span class="n">geb_pos</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">pf</span><span class="p">)</span>
            <span class="c1">//产生错误信息并退出</span>
        <span class="n">_len</span> <span class="o">=</span> <span class="n">len</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">?</span><span class="n">len</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">_beg_pos</span> <span class="o">=</span> <span class="n">beg_pos</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">?</span><span class="n">beg_pos</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
        
        <span class="n">pf</span><span class="p">(</span><span class="n">beg_pos</span><span class="o">+</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">_elems</span><span class="p">);</span>
    <span class="p">}</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">_len</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_beg_pos</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">_elems</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c1">//pf是一个指向“依据特定数列类型，产生pos个元素，放到vector seq内”的函数</span>
<span class="c1">//用法如下：</span>
<span class="kt">void</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">,</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="n">seq</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">pell</span><span class="p">(</span><span class="kt">int</span> <span class="n">pos</span><span class="p">,</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="n">seq</span><span class="p">);</span>

<span class="n">numeric_sequence</span><span class="o">&lt;</span><span class="n">fibonacci</span><span class="o">&gt;</span> <span class="n">ns_fib</span><span class="p">(</span><span class="mi">12</span><span class="p">);</span>
<span class="n">numeric_sequence</span><span class="o">&lt;</span><span class="n">pell</span><span class="o">&gt;</span> <span class="n">ns_pell</span><span class="p">(</span><span class="mi">18</span><span class="p">,</span><span class="mi">8</span><span class="p">);</span>
</pre></table></code></div></div><h2 id="67-以template参数作为一种设计策略"><span class="mr-2">6.7 以Template参数作为一种设计策略</span><a href="#67-以template参数作为一种设计策略" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="n">tyename</span> <span class="n">elemType</span><span class="p">,</span><span class="k">typename</span> <span class="nc">Comp</span> <span class="o">=</span> <span class="n">less</span><span class="o">&lt;</span><span class="n">elemType</span><span class="p">&gt;</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">LessThanPred</span><span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">LessThanPred</span><span class="p">(</span><span class="k">const</span> <span class="n">elemType</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span><span class="o">:</span><span class="n">_val</span><span class="p">(</span><span class="n">val</span><span class="p">){}</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">elemType</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span><span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Comp</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="n">_val</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">val</span><span class="p">(</span><span class="k">const</span> <span class="n">elemType</span> <span class="o">&amp;</span><span class="n">newval</span><span class="p">){</span><span class="n">_val</span> <span class="o">=</span> <span class="n">newval</span><span class="p">;}</span>
    <span class="n">elemType</span> <span class="n">val</span><span class="p">()</span><span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">_val</span><span class="p">;}</span>
<span class="nl">private:</span>
    <span class="n">elemType</span> <span class="n">_val</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">StringLen</span><span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">s1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&lt;</span><span class="n">s2</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">//应用</span>
<span class="n">LessThanPred</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ltpi</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span>
<span class="n">LessThanPred</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">StringLen</span><span class="o">&gt;</span> <span class="n">ltps</span><span class="p">(</span><span class="s">"Pooh"</span><span class="p">);</span>
</pre></table></code></div></div><h2 id="68-member-template-function"><span class="mr-2">6.8 Member Template Function</span><a href="#68-member-template-function" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">PrintIt</span><span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">PrintIt</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">)</span><span class="o">:</span><span class="n">_os</span><span class="p">(</span><span class="n">os</span><span class="p">){}</span>
    <span class="c1">//成员模板函数</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">elemType</span><span class="p">&gt;</span>
    <span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="k">const</span> <span class="n">elemType</span> <span class="o">&amp;</span><span class="n">elem</span><span class="p">,</span><span class="kt">char</span> <span class="n">delimiter</span> <span class="o">=</span> <span class="sc">'\n'</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_os</span><span class="o">&lt;&lt;</span><span class="n">elem</span><span class="o">&lt;&lt;</span><span class="n">delimiter</span><span class="p">;</span>
    <span class="p">}</span>
<span class="nl">private:</span>
    <span class="n">ostream</span><span class="o">&amp;</span> <span class="n">_os</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">PrintIt</span> <span class="n">to_standard_out</span><span class="p">(</span><span class="n">cout</span><span class="p">);</span>
    <span class="n">to_standard_out</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>
    <span class="n">to_standard_out</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span>
    
    <span class="n">string</span> <span class="n">my_string</span><span class="p">(</span><span class="s">"i am a string"</span><span class="p">);</span>
    <span class="n">to_standard_out</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">my_string</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h1 id="第7章-异常处理">第7章 异常处理</h1><h2 id="71-抛出异常"><span class="mr-2">7.1 抛出异常</span><a href="#71-抛出异常" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>异常处理机制：异常的鉴定与发出、异常的处理方式。</p><p>异常出现之后，程序被暂停，异常处理机制开始搜索程序中有能力处理这一异常的地点，异常被处理完毕之后，程序的执行便会继续，从异常处理点接着执行下去。</p><p>C++通过throw表达式产生异常，throw表达式类似函数调用</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kr">inline</span> <span class="kt">void</span> <span class="n">Triangular_iterator</span><span class="o">::</span><span class="n">check_interity</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">_index</span><span class="o">&gt;=</span><span class="n">Triangular</span><span class="o">::</span><span class="n">_max_elems</span><span class="p">)</span>
        <span class="k">throw</span> <span class="n">iterator_overflow</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">Triangular</span><span class="o">::</span><span class="n">_max_elems</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">_index</span><span class="o">&gt;=</span><span class="n">Triangular</span><span class="o">::</span><span class="n">_elems</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
        <span class="n">Triangular</span><span class="o">::</span><span class="n">gen_elements</span><span class="p">(</span><span class="n">_index</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">iterator_overflow</span><span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">iterator_overflow</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span><span class="kt">int</span> <span class="n">max</span><span class="p">)</span><span class="o">:</span><span class="n">_index</span><span class="p">(</span><span class="n">index</span><span class="p">),</span><span class="n">_max</span><span class="p">(</span><span class="n">max</span><span class="p">){}</span>
    <span class="kt">int</span> <span class="n">index</span><span class="p">(){</span><span class="k">return</span> <span class="n">_index</span><span class="p">;}</span>
    <span class="kt">int</span> <span class="n">max</span><span class="p">(){</span><span class="k">return</span> <span class="n">_max</span><span class="p">;}</span>
    
    <span class="kt">void</span> <span class="n">what_happened</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="o">=</span><span class="n">cerr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">os</span><span class="o">&lt;&lt;</span><span class="s">"Internal error current index "</span>
            <span class="o">&lt;&lt;</span><span class="n">_index</span><span class="o">&lt;&lt;</span><span class="s">" exceeds maximum bound: "</span><span class="o">&lt;&lt;</span><span class="n">_max</span><span class="p">;</span>
    <span class="p">}</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">_index</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_max</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="72-捕获异常"><span class="mr-2">7.2 捕获异常</span><a href="#72-捕获异常" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>利用单条或一连串的catch子句来捕获(catch)被抛出的异常。catch子句由三部分组成：关键字catch、小括号内的一个类型或对象、大括号内的一组语句（用来处理异常）。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="k">extern</span> <span class="kt">void</span> <span class="nf">log_message</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">string</span> <span class="n">err_messages</span><span class="p">[];</span>
<span class="k">extern</span> <span class="n">ostream</span> <span class="n">log_file</span><span class="p">;</span>

<span class="kt">bool</span> <span class="nf">some_function</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">status</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    
    <span class="k">catch</span><span class="p">(</span><span class="kt">int</span> <span class="n">errno</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">log_message</span><span class="p">(</span><span class="n">err_messages</span><span class="p">[</span><span class="n">errno</span><span class="p">]);</span>
        <span class="n">status</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">log_message</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
        <span class="n">status</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">catch</span><span class="p">(</span><span class="n">iterator_overflow</span> <span class="o">&amp;</span><span class="n">iof</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">iof</span><span class="p">.</span><span class="n">what_happened</span><span class="p">(</span><span class="n">log_file</span><span class="p">);</span>
        <span class="n">status</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>上述语句可以处理前一节所抛出的三个异常对象：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">throw</span> <span class="mi">42</span><span class="p">;</span>
<span class="k">throw</span> <span class="s">"panic:no buffer!"</span><span class="p">;</span>
<span class="k">throw</span> <span class="nf">iterator_overflow</span><span class="p">(</span><span class="n">_index</span><span class="p">,</span><span class="n">Triangular</span><span class="o">::</span><span class="n">_max_elems</span><span class="p">);</span>
</pre></table></code></div></div><p>有时候我们无法完成异常的完整处理，需要重新抛出异常，寻求其它catch子句的协助：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">catch</span><span class="p">(</span><span class="n">iterator_overflow</span> <span class="o">&amp;</span><span class="n">iof</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">log_message</span><span class="p">(</span><span class="n">iof</span><span class="p">.</span><span class="n">what_happened</span><span class="p">());</span>
    <span class="c1">//重新抛出异常，令另一个catch子句接手处理</span>
    <span class="k">throw</span><span class="p">;</span> <span class="c1">//重新抛出时，只需写下throw关键字即可</span>
<span class="p">}</span>
</pre></table></code></div></div><p>如果想捕获任何类型的异常，在异常声明部分指定省略号即可：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">catch</span><span class="p">(...)</span>
<span class="p">{</span>
    <span class="n">log_message</span><span class="p">(</span><span class="s">"exception of unknown type"</span><span class="p">);</span>
    <span class="c1">//清理(clean up)然后退出</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="73-提炼异常"><span class="mr-2">7.3 提炼异常</span><a href="#73-提炼异常" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>catch子句和try块一起使用。try块以关键字try作为开始，然后是大括号内的一连串程序语句。catch子句放在try块的末尾，这表示如果try块内有任何异常发生，便由接下来的catch子句加以处理。C++规定每一个异常都应该被处理。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="nf">has_elem</span><span class="p">(</span><span class="n">Triangular_iterator</span> <span class="n">first</span><span class="p">,</span><span class="n">Triangular_iterator</span> <span class="n">last</span><span class="p">,</span><span class="kt">int</span> <span class="n">elem</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">status</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="n">first</span><span class="o">!=</span><span class="n">last</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="o">==</span><span class="n">elem</span><span class="p">)</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="o">++</span><span class="n">first</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">//捕获异常</span>
    <span class="k">catch</span><span class="p">(</span><span class="n">iterator_overflow</span> <span class="o">&amp;</span><span class="n">iof</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">log_message</span><span class="p">(</span><span class="n">iof</span><span class="p">.</span><span class="n">what_happened</span><span class="p">());</span>
        <span class="n">log_message</span><span class="p">(</span><span class="s">"check if iterator address same container"</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="n">status</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="75-标准异常"><span class="mr-2">7.5 标准异常</span><a href="#75-标准异常" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>如果new表达式无法从程序的空闲空间分配到足够的内存，它会抛出bad_alloc异常对象。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;*</span> <span class="nf">init_text_vector</span><span class="p">(</span><span class="n">ifstream</span> <span class="o">&amp;</span><span class="n">infile</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;*</span><span class="n">ptext</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">try</span><span class="p">{</span>
        <span class="n">ptext</span> <span class="o">=</span> <span class="k">new</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">;</span>
        
    <span class="p">}</span>
    <span class="k">catch</span><span class="p">(</span><span class="n">bad_alloc</span><span class="p">){</span>
        <span class="n">cerr</span><span class="o">&lt;&lt;</span><span class="s">"ouch.headp memory exhausted!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ptext</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>标准库定义了一套异常类体系，其根部是名为exception的抽象基类。exception声明有一个what()虚函数，会返回一个const char*，来表示被抛出异常的文字描述。</p><p>将自己编写的iterator_overflow继承于exception基类之下，并提供自己的what()。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="cp">#include</span><span class="cpf">&lt;exception&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">iterator_overflow</span> <span class="o">:</span> <span class="k">public</span> <span class="n">exception</span><span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">iterator_overflow</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span><span class="kt">int</span> <span class="n">max</span><span class="p">)</span><span class="o">:</span><span class="n">_index</span><span class="p">(</span><span class="n">index</span><span class="p">),</span><span class="n">_max</span><span class="p">(</span><span class="n">max</span><span class="p">){}</span>
    <span class="kt">int</span> <span class="n">index</span><span class="p">(){</span><span class="k">return</span> <span class="n">_index</span><span class="p">;}</span>
    <span class="kt">int</span> <span class="n">max</span><span class="p">(){</span><span class="k">return</span> <span class="n">_max</span><span class="p">;}</span>
    
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">what</span><span class="p">()</span><span class="k">const</span><span class="p">;</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">_index</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_max</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="cp">#include</span><span class="cpf">&lt;sstream&gt;</span><span class="c1">  //使用ostringstream class</span><span class="cp">
#include</span><span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">iterator_overflow</span><span class="o">::</span><span class="n">what</span><span class="p">()</span><span class="k">const</span>
<span class="p">{</span>
    <span class="n">ostringstream</span> <span class="n">ex_msg</span><span class="p">;</span><span class="c1">//可以将int等对象转化为对应的字符串</span>
    <span class="k">static</span> <span class="n">string</span> <span class="n">msg</span><span class="p">;</span>
    
    <span class="n">ex_msg</span><span class="o">&lt;&lt;</span><span class="s">"Internal error: current index "</span><span class="o">&lt;&lt;</span><span class="n">_index</span><span class="o">&lt;&lt;</span><span class="s">" exceeds maxium bound: "</span><span class="o">&lt;&lt;</span><span class="n">_max</span><span class="p">;</span>
    
    <span class="c1">//萃取出string对象</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">ex_msg</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
    
    <span class="c1">//萃取出const char*表达式</span>
    <span class="k">return</span> <span class="n">msg</span><span class="p">.</span><span class="n">c_str</span><span class="p">();;</span> <span class="c1">//将string转化为C-Style字符串</span>
<span class="p">}</span>
</pre></table></code></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/c/'>C++</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%E4%BE%AF%E6%8D%B7/" class="post-tag no-text-decoration" >侯捷</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Essential+C%2B%2B+-+jlwang1998&url=https%3A%2F%2Fjlwang1998.github.io%2Fposts%2FEssential-C%2B%2B%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Essential+C%2B%2B+-+jlwang1998&u=https%3A%2F%2Fjlwang1998.github.io%2Fposts%2FEssential-C%2B%2B%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fjlwang1998.github.io%2Fposts%2FEssential-C%2B%2B%2F&text=Essential+C%2B%2B+-+jlwang1998" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/">机器学习面试八股</a><li><a href="/posts/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">动手学深度学习</a><li><a href="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><li><a href="/posts/C++%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/">C++学习路线</a><li><a href="/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E9%9D%A2%E7%BB%8F/">机器学习算法面经</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95/">算法</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/test/">Test</a> <a class="post-tag" href="/tags/%E4%BE%AF%E6%8D%B7/">侯捷</a> <a class="post-tag" href="/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/">学习路线</a> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a> <a class="post-tag" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a> <a class="post-tag" href="/tags/%E6%9C%BA%E8%AF%95/">机试</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/C++%E9%9A%BE%E7%82%B9/"><div class="card-body"> <em class="small" data-ts="1650024000" data-df="YYYY-MM-DD" > 2022-04-15 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++难点</h3><div class="text-muted small"><p> 1、C++ 11有哪些新特性？ nullptr替代 NULL 引入了 auto 和 decltype 这两个关键字实现了类型推导 基于范围的 for 循环for(auto&amp;amp; i : res){} 类和结构体的中初始化列表 Lambda 表达式（匿名函数） std::forward_list（单向链表） 右值引用和move语义 … 2、auto、...</p></div></div></a></div><div class="card"> <a href="/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><div class="card-body"> <em class="small" data-ts="1658196000" data-df="YYYY-MM-DD" > 2022-07-19 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>操作系统</h3><div class="text-muted small"><p> 1. 操作系统概述 1.1 操作系统的概念、功能和目标 联机命令接口：交互式命令接口，如time 脱机命令接口：批处理命令接口 程序接口：.dll文件 1.2 操作系统的特征 并发、共享、虚拟、异步。并发和共享是两个最基本的特征，二者互为存在条件。 并发和并行不同：并发宏观上是同时发生的微观上是交替发生，并行是多个事件同时发生。 共享：资源共享，指系统中的资源可供...</p></div></div></a></div><div class="card"> <a href="/posts/MyFirstBlog/"><div class="card-body"> <em class="small" data-ts="1650610800" data-df="YYYY-MM-DD" > 2022-04-22 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>我的第一篇博客！</h3><div class="text-muted small"><p> 这是我的第一篇博客 这里可以放代码片段噢～ 1 2 3 4 //代码片段 int main(){ hello world; }</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/C++%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/" class="btn btn-outline-primary" prompt="上一篇"><p>C++学习路线</p></a> <a href="/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E9%9D%A2%E7%BB%8F/" class="btn btn-outline-primary" prompt="下一篇"><p>机器学习算法面经</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/username">jlwang1998</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95/">算法</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/test/">Test</a> <a class="post-tag" href="/tags/%E4%BE%AF%E6%8D%B7/">侯捷</a> <a class="post-tag" href="/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/">学习路线</a> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a> <a class="post-tag" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a> <a class="post-tag" href="/tags/%E6%9C%BA%E8%AF%95/">机试</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3"></p><button type="button" class="btn btn-primary" aria-label="Update"> </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/asia/xi'an.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
